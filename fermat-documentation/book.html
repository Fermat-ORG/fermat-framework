<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Asciidoctor 0.1.4">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fermat Documentation</title>
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }
audio, canvas, video { display: inline-block; }
audio:not([controls]) { display: none; height: 0; }
[hidden] { display: none; }
html { background: #fff; color: #000; font-family: sans-serif; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; }
body { margin: 0; }
a:focus { outline: thin dotted; }
a:active, a:hover { outline: 0; }
h1 { font-size: 2em; margin: 0.67em 0; }
abbr[title] { border-bottom: 1px dotted; }
b, strong { font-weight: bold; }
dfn { font-style: italic; }
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }
mark { background: #ff0; color: #000; }
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }
pre { white-space: pre-wrap; }
q { quotes: "\201C" "\201D" "\2018" "\2019"; }
small { font-size: 80%; }
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }
img { border: 0; }
svg:not(:root) { overflow: hidden; }
figure { margin: 0; }
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }
legend { border: 0; padding: 0; }
button, input, select, textarea { font-family: inherit; font-size: 100%; margin: 0; }
button, input { line-height: normal; }
button, select { text-transform: none; }
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; cursor: pointer; }
button[disabled], html input[disabled] { cursor: default; }
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; padding: 0; }
input[type="search"] { -webkit-appearance: textfield; -moz-box-sizing: content-box; -webkit-box-sizing: content-box; box-sizing: content-box; }
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }
textarea { overflow: auto; vertical-align: top; }
table { border-collapse: collapse; border-spacing: 0; }
*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }
html, body { font-size: 100%; }
body { background: white; color: #222222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }
a:hover { cursor: pointer; }
a:focus { outline: none; }
img, object, embed { max-width: 100%; height: auto; }
object, embed { height: 100%; }
img { -ms-interpolation-mode: bicubic; }
#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }
.left { float: left !important; }
.right { float: right !important; }
.text-left { text-align: left !important; }
.text-right { text-align: right !important; }
.text-center { text-align: center !important; }
.text-justify { text-align: justify !important; }
.hide { display: none; }
.antialiased, body { -webkit-font-smoothing: antialiased; }
img { display: inline-block; vertical-align: middle; }
textarea { height: auto; min-height: 50px; }
select { width: 100%; }
p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }
.subheader, #content #toctitle, .admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title, .tableblock > caption { line-height: 1.4; color: #7a2518; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }
a { color: #005498; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #00467f; }
a img { border: none; }
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: Georgia, "URW Bookman L", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; color: #ba3925; text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #e99b8f; line-height: 0; }
h1 { font-size: 2.125em; }
h2 { font-size: 1.6875em; }
h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }
h4 { font-size: 1.125em; }
h5 { font-size: 1.125em; }
h6 { font-size: 1em; }
hr { border: solid #dddddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }
em, i { font-style: italic; line-height: inherit; }
strong, b { font-weight: bold; line-height: inherit; }
small { font-size: 60%; line-height: inherit; }
code { font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; color: #6d180b; }
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }
ul, ol { margin-left: 1.5em; }
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }
abbr, acronym { text-transform: uppercase; font-size: 90%; color: #222222; border-bottom: 1px dotted #dddddd; cursor: help; }
abbr { text-transform: none; }
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: inherit; color: #555555; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #555555; }
blockquote, blockquote p { line-height: 1.6; color: #6f6f6f; }
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }
.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }
@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
.print-only { display: none !important; }
@media print { * { background: transparent !important; color: #000 !important; box-shadow: none !important; text-shadow: none !important; }
  a, a:visited { text-decoration: underline; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
  thead { display: table-header-group; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page { margin: 0.5cm; }
  p, h2, h3, #toctitle, .sidebarblock > .content > .title { orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }
table { background: white; margin-bottom: 1.25em; border: solid 1px #dddddd; }
table thead, table tfoot { background: whitesmoke; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: #222222; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: #222222; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f9f9f9; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }
.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }
*:not(pre) > code { font-size: 0.9375em; padding: 1px 3px 0; white-space: nowrap; background-color: #f2f2f2; border: 1px solid #cccccc; -webkit-border-radius: 4px; border-radius: 4px; text-shadow: none; }
pre, pre > code { line-height: 1.4; color: inherit; font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; }
kbd.keyseq { color: #555555; }
kbd:not(.keyseq) { display: inline-block; color: #222222; font-size: 0.75em; line-height: 1.4; background-color: #F7F7F7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; margin: -0.15em 0.15em 0 0.15em; padding: 0.2em 0.6em 0.2em 0.5em; vertical-align: middle; white-space: nowrap; }
kbd kbd:first-child { margin-left: 0; }
kbd kbd:last-child { margin-right: 0; }
.menuseq, .menu { color: #090909; }
p a > code:hover { color: #561309; }
#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }
#header { margin-bottom: 2.5em; }
#header > h1 { color: black; font-weight: normal; border-bottom: 1px solid #dddddd; margin-bottom: -28px; padding-bottom: 32px; }
#header span { color: #6f6f6f; }
#header #revnumber { text-transform: capitalize; }
#header br { display: none; }
#header br + span { padding-left: 3px; }
#header br + span:before { content: "\2013 \0020"; }
#header br + span.author { padding-left: 0; }
#header br + span.author:before { content: ", "; }
#toc { border-bottom: 3px double #ebebeb; padding-bottom: 1.25em; }
#toc > ul { margin-left: 0.25em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
#toc ul { list-style-type: none; }
#toctitle { color: #7a2518; }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; }
  #toc.toc2 { position: fixed; width: 20em; left: 0; top: 0; border-right: 1px solid #ebebeb; border-bottom: 0; z-index: 1000; padding: 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; }
  #toc.toc2 > ul { font-size: .95em; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1.25em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; }
  body.toc2.toc-right #toc.toc2 { border-right: 0; border-left: 1px solid #ebebeb; left: auto; right: 0; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; border-width: 0; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }
#content #toc a { text-decoration: none; }
#content #toctitle { font-weight: bold; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-size: 1em; padding-left: 0.125em; }
#footer { max-width: 100%; background-color: #222222; padding: 1.25em; }
#footer-text { color: #dddddd; line-height: 1.44; }
.sect1 { padding-bottom: 1.25em; }
.sect1 + .sect1 { border-top: 3px double #ebebeb; }
#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; width: 1em; margin-left: -1em; display: block; text-decoration: none; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: '\00A7'; font-size: .85em; vertical-align: text-top; display: block; margin-top: 0.05em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #ba3925; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #a53221; }
.imageblock, .literalblock, .listingblock, .verseblock, .videoblock { margin-bottom: 1.25em; }
.admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-align: left; font-weight: bold; }
.tableblock > caption { text-align: left; font-weight: bold; white-space: nowrap; overflow: visible; max-width: 0; }
table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }
.admonitionblock > table { border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #dddddd; color: #6f6f6f; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }
.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6, .exampleblock > .content p { color: #333333; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6 { line-height: 1; margin-bottom: 0.625em; }
.exampleblock > .content h1.subheader, .exampleblock > .content h2.subheader, .exampleblock > .content h3.subheader, .exampleblock > .content .subheader#toctitle, .sidebarblock.exampleblock > .content > .subheader.title, .exampleblock > .content h4.subheader, .exampleblock > .content h5.subheader, .exampleblock > .content h6.subheader { line-height: 1.4; }
.exampleblock.result > .content { -webkit-box-shadow: 0 1px 8px #d9d9d9; box-shadow: 0 1px 8px #d9d9d9; }
.sidebarblock { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6, .sidebarblock p { color: #333333; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6 { line-height: 1; margin-bottom: 0.625em; }
.sidebarblock h1.subheader, .sidebarblock h2.subheader, .sidebarblock h3.subheader, .sidebarblock .subheader#toctitle, .sidebarblock > .content > .subheader.title, .sidebarblock h4.subheader, .sidebarblock h5.subheader, .sidebarblock h6.subheader { line-height: 1.4; }
.sidebarblock > .content > .title { color: #7a2518; margin-top: 0; line-height: 1.6; }
.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }
.literalblock > .content pre, .listingblock > .content pre { background: none; border-width: 1px 0; border-style: dotted; border-color: #bfbfbf; -webkit-border-radius: 4px; border-radius: 4px; padding: 0.75em 0.75em 0.5em 0.75em; word-wrap: break-word; }
.literalblock > .content pre.nowrap, .listingblock > .content pre.nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
.literalblock > .content pre > code, .listingblock > .content pre > code { display: block; }
@media only screen { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.8em; } }
@media only screen and (min-width: 768px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.9em; } }
@media only screen and (min-width: 1280px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 1em; } }
.listingblock > .content { position: relative; }
.listingblock:hover code[class*=" language-"]:before { text-transform: uppercase; font-size: 0.9em; color: #999; position: absolute; top: 0.375em; right: 0.375em; }
.listingblock:hover code.asciidoc:before { content: "asciidoc"; }
.listingblock:hover code.clojure:before { content: "clojure"; }
.listingblock:hover code.css:before { content: "css"; }
.listingblock:hover code.groovy:before { content: "groovy"; }
.listingblock:hover code.html:before { content: "html"; }
.listingblock:hover code.java:before { content: "java"; }
.listingblock:hover code.javascript:before { content: "javascript"; }
.listingblock:hover code.python:before { content: "python"; }
.listingblock:hover code.ruby:before { content: "ruby"; }
.listingblock:hover code.scss:before { content: "scss"; }
.listingblock:hover code.xml:before { content: "xml"; }
.listingblock:hover code.yaml:before { content: "yaml"; }
.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }
.listingblock.terminal pre .command:not([data-prompt]):before { content: '$'; }
table.pyhltable { border: 0; margin-bottom: 0; }
table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; }
table.pyhltable td.code { padding-left: .75em; padding-right: 0; }
.highlight.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #dddddd; }
.highlight.pygments .lineno { display: inline-block; margin-right: .25em; }
table.pyhltable .linenodiv { background-color: transparent !important; padding-right: 0 !important; }
.quoteblock { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
.quoteblock blockquote { margin: 0 0 1.25em 0; padding: 0 0 0.5625em 0; border: 0; }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: -.25em; padding-bottom: 0.5625em; font-size: inherit; color: #555555; }
.quoteblock .attribution br { display: none; }
.quoteblock .attribution cite { display: block; margin-bottom: 0.625em; }
table thead th, table tfoot th { font-weight: bold; }
table.tableblock.grid-all { border-collapse: separate; border-spacing: 1px; -webkit-border-radius: 4px; border-radius: 4px; border-top: 1px solid #dddddd; border-bottom: 1px solid #dddddd; }
table.tableblock.frame-topbot, table.tableblock.frame-none { border-left: 0; border-right: 0; }
table.tableblock.frame-sides, table.tableblock.frame-none { border-top: 0; border-bottom: 0; }
table.tableblock td .paragraph:last-child p, table.tableblock td > p:last-child { margin-bottom: 0; }
th.tableblock.halign-left, td.tableblock.halign-left { text-align: left; }
th.tableblock.halign-right, td.tableblock.halign-right { text-align: right; }
th.tableblock.halign-center, td.tableblock.halign-center { text-align: center; }
th.tableblock.valign-top, td.tableblock.valign-top { vertical-align: top; }
th.tableblock.valign-bottom, td.tableblock.valign-bottom { vertical-align: bottom; }
th.tableblock.valign-middle, td.tableblock.valign-middle { vertical-align: middle; }
p.tableblock.header { color: #222222; font-weight: bold; }
td > div.verse { white-space: pre; }
ol { margin-left: 1.75em; }
ul li ol { margin-left: 1.5em; }
dl dd { margin-left: 1.125em; }
dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }
ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }
ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }
ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }
ul.checklist li > p:first-child > i[class^="icon-check"]:first-child, ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }
ul.checklist li > p:first-child > input[type="checkbox"]:first-child { position: relative; top: 1px; }
ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }
.unstyled dl dt { font-weight: normal; font-style: normal; }
ol.arabic { list-style-type: decimal; }
ol.decimal { list-style-type: decimal-leading-zero; }
ol.loweralpha { list-style-type: lower-alpha; }
ol.upperalpha { list-style-type: upper-alpha; }
ol.lowerroman { list-style-type: lower-roman; }
ol.upperroman { list-style-type: upper-roman; }
ol.lowergreek { list-style-type: lower-greek; }
.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }
td.hdlist1 { padding-right: .8em; font-weight: bold; }
td.hdlist1, td.hdlist2 { vertical-align: top; }
.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }
.colist > table tr > td:first-of-type { padding: 0 .8em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }
.qanda > ol > li > p > em:only-child { color: #00467f; }
.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }
.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }
.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }
a.image { text-decoration: none; }
span.footnote, span.footnoteref { vertical-align: super; font-size: 0.875em; }
span.footnote a, span.footnoteref a { text-decoration: none; }
#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -.25em 0 .75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em; line-height: 1.3; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.2em; margin-bottom: .2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }
.gist .file-data > table { border: none; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }
div.unbreakable { page-break-inside: avoid; }
.big { font-size: larger; }
.small { font-size: smaller; }
.underline { text-decoration: underline; }
.overline { text-decoration: overline; }
.line-through { text-decoration: line-through; }
.aqua { color: #00bfbf; }
.aqua-background { background-color: #00fafa; }
.black { color: black; }
.black-background { background-color: black; }
.blue { color: #0000bf; }
.blue-background { background-color: #0000fa; }
.fuchsia { color: #bf00bf; }
.fuchsia-background { background-color: #fa00fa; }
.gray { color: #606060; }
.gray-background { background-color: #7d7d7d; }
.green { color: #006000; }
.green-background { background-color: #007d00; }
.lime { color: #00bf00; }
.lime-background { background-color: #00fa00; }
.maroon { color: #600000; }
.maroon-background { background-color: #7d0000; }
.navy { color: #000060; }
.navy-background { background-color: #00007d; }
.olive { color: #606000; }
.olive-background { background-color: #7d7d00; }
.purple { color: #600060; }
.purple-background { background-color: #7d007d; }
.red { color: #bf0000; }
.red-background { background-color: #fa0000; }
.silver { color: #909090; }
.silver-background { background-color: #bcbcbc; }
.teal { color: #006060; }
.teal-background { background-color: #007d7d; }
.white { color: #bfbfbf; }
.white-background { background-color: #fafafa; }
.yellow { color: #bfbf00; }
.yellow-background { background-color: #fafa00; }
span.icon > [class^="icon-"], span.icon > [class*=" icon-"] { cursor: default; }
.admonitionblock td.icon [class^="icon-"]:before { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #005498; color: #003f72; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }
.conum { display: inline-block; color: white !important; background-color: #222222; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; width: 20px; height: 20px; font-size: 12px; font-weight: bold; line-height: 20px; font-family: Arial, sans-serif; font-style: normal; position: relative; top: -2px; letter-spacing: -1px; }
.conum * { color: white !important; }
.conum + b { display: none; }
.conum:after { content: attr(data-value); }
.conum:not([data-value]):empty { display: none; }
.literalblock > .content > pre, .listingblock > .content > pre { -webkit-border-radius: 0; border-radius: 0; }

</style>
</head>
<body class="book">
<div id="header">
<h1>Fermat Documentation</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="DocumentationOrganization">Documentation Organization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The system documentation is written is asciidoc format in order to be portable to many formats.<br>
We will decompose the system in the following way:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First we will describe the system functionality as a whole app, where we will describe the actors and sub-apps involved in the system.</p>
</li>
<li>
<p>The next part is divided in the description of each layer. Inside every layer section we will find a general explanation of the layer, and follow by a list of all the plug-ins living in the layer.</p>
</li>
<li>
<p>Every plug-in will have its own subdivision, where we will find one reference for every developer who is in charge of an implementation of the plug-in.</p>
</li>
<li>
<p>Then each developer will have a final subdivision of its documentation to refer separately to the different version of the plug-in implemented.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In this way we will get a central documentation where we will find a whole range of information about the system, from usage examples of the application to technical description of the plug-ins. We don&#8217;t want show code in this document, all the implementation details will be described inside the source files. Although, we will see in some cases technical discussions about the implementation challenges described in a slightly more abstract way than the source code.</p>
</div>
<div class="paragraph">
<p>So, the general structure of this document can be seen in the following way</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Platform Description</p>
<div class="ulist">
<ul>
<li>
<p>Layer Description</p>
<div class="ulist">
<ul>
<li>
<p>Plug-in Developer Index</p>
<div class="ulist">
<ul>
<li>
<p>Developer Version Index</p>
<div class="ulist">
<ul>
<li>
<p>Version Description</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<h1 id="PlatformDescription" class="sect0">Platform Description</h1>
<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the following sections we will explore:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The functional description of this system (what is Fermat? how can we use it?).</p>
</li>
<li>
<p>The <a href="#PlatformDescription-Wallets">wallets</a> and <a href="#PlatformDescription-SubApps">applications</a> that run over this platform.</p>
</li>
<li>
<p>The <a href="#PlatformDescription-SourceCode">code distribution and essentials concepts</a> needed to.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="PlatformDescription-Wallets">Wallets</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_bitcoin_wallet">Bitcoin Wallet</h3>
<div class="paragraph">
<p>This wallet is represented by the Nich Wallet Bitcoin Reference Wallet.<br>
We will explore the functionality of this wallet and all the modules involved in different work cycles.<br></p>
</div>
</div>
<div class="sect2">
<h3 id="_argentina_bitcoin_wallet">Argentina Bitcoin Wallet</h3>
<div class="paragraph">
<p>to be completed</p>
</div>
</div>
<div class="sect2">
<h3 id="_bitcoin_loss_protected_wallet">Bitcoin Loss Protected Wallet</h3>
<div class="paragraph">
<p>to be completed</p>
</div>
</div>
<div class="sect2">
<h3 id="_argentina_loss_protected_wallet">Argentina Loss Protected Wallet</h3>
<div class="paragraph">
<p>to be completed</p>
</div>
</div>
<div class="sect2">
<h3 id="_argentina_discount_wallet">Argentina Discount Wallet</h3>
<div class="paragraph">
<p>to be completed</p>
</div>
</div>
<div class="sect2">
<h3 id="_rounded_wallet">Rounded Wallet</h3>
<div class="paragraph">
<p>to be completed</p>
</div>
</div>
<div class="sect2">
<h3 id="_argentina_multi_account_wallet">Argentina Multi Account Wallet</h3>
<div class="paragraph">
<p>to be completed</p>
</div>
</div>
<div class="sect2">
<h3 id="_argentina_bank_notes_wallet">Argentina Bank Notes Wallet</h3>
<div class="paragraph">
<p>to be completed</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="PlatformDescription-SubApps">Subapplications</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is important to mention that every subapp described here is divided in a user interface and a logic module. The application UI runs over the platform and the logic that control the app lives inside the platform. This means that for each subapplication we will find a plug-in in the <a href="#Fermat-DMP-ModuleLayer">module layer</a> that implements the behavior of the app.</p>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-Shell">Shell</h3>
<div class="paragraph">
<p>Brings the available functionality when no user has logged in.<br>
Some trivial functionalities are the login functionality, account creation, forgotten password, etc.<br></p>
</div>
<div class="paragraph">
<p>The login policies are pending to be discussed. One initial idea is that the login should not be done every time the user opens the Fermat app or turn on the device. However we should consider that this could be a kind of security mechanism, we could also have expiration session times.<br></p>
</div>
<div class="paragraph">
<p>Another idea is to set a limit in the amount of money the user can manage without logging in.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-WalletManager">Wallet Manager</h3>
<div class="paragraph">
<p>This app let the user administrate the different <a href="#PlatformDescription-Wallets">wallets</a> a he has installed in his device.<br>
There are some operations between wallets that may be appropriate for this module to handle, for example we could manage transactions between wallets of a same user using this app.<br></p>
</div>
<div class="paragraph">
<p>The first set of wallets will be installed by default, in the future the manager will get new wallets from the <a href="#Platform-SubApps-WalletStore">wallet store</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-WalletFactory">Wallet Factory</h3>
<div class="paragraph">
<p>This subapp is focused in developers, it lets a user edit the navigation structure of a wallet and create what we call a wallet factory project.<br>
This projects will be managed by a subapp called <a href="#Platform-SubApps-WalletPublisher">Wallet Publisher</a>.</p>
</div>
<div class="paragraph">
<p>When a user edit a wallet he can set (add) the resources (like images) the wallet use.<br>
Those resources are not saved in the wallet runtime but are referenced using the wallet resources plug-in.<br></p>
</div>
<div class="paragraph">
<p>When the wallet manager install a new wallet it ask the corresponding resources to the wallet resources plug-in.<br></p>
</div>
<div class="paragraph">
<p>At this moment the resources are stored in a github repository associated to each wallet. In the future we plan to avoid the necessity of a central point of reference to download resources and to have them distributed over the platform&#8217;s users.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-WalletPublisher">Wallet Publisher</h3>
<div class="paragraph">
<p>This subapp can read the output product of the <a href="#Platform-SubApps-WalletFactory">wallet factory</a> which are files called wallet factory projects.</p>
</div>
</div>
<div class="sect2">
<h3 id="_this_need_to_be_revised_explained">THIS NEED TO BE REVISED/EXPLAINED</h3>
<div class="paragraph">
<p>This module publish the new wallet in the wallet store.<br>
When another user installs the new wallet, this subapp will configure the wallet runtime to run the new wallet (??)</p>
</div>
<div class="paragraph">
<p>This module also let a wallet administrator (developer, marketing agency, brand, etc) interact with the wallet users and know some statistics to be defined like number of users.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-WalletStore">Wallet Store</h3>
<div class="paragraph">
<p>This subapp shows the user the different wallets he can download and install in his device.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-WalletEditor">Wallet Editor</h3>
<div class="paragraph">
<p>This subapp let an actor take any wallet in the <a href="#Platform-SubApps-WalletStore">wallet store</a> and edit it. The subapp is focused to marketing agencies.<br>
Here edition means that the subapp will take the navigation structure of the selected wallet from the wallet runtime and copy it to what we will call a wallet editor project.<br>
Basically, the edition let the actor change the navigation structure and user interface, but it doesn&#8217;t let you change the wallet business logic.</p>
</div>
<div class="paragraph">
<p>This editor let the actors change the resources settled by the <a href="#Platform-SubApps-WalletFactory">wallet factory</a> and basically make a fork of the wallet.<br></p>
</div>
<div class="paragraph">
<p>Following the life cycle, this project will be taken by a particular brand before the publishing of the wallet.</p>
</div>
</div>
<div class="sect2">
<h3 id="_wallet_licensing">Wallet Licensing</h3>

</div>
<div class="sect2">
<h3 id="Platform-SubApps-ShopManager">Shop Manager</h3>
<div class="paragraph">
<p>Similar to the <a href="#Platform-SubApps-WalletManager">wallet manager</a> this subapp let shop owners administrate their different shops in this platform.<br>
The shops are individually managed using the <a href="#Platform-SubApps-shop">shop subapp</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-Shop">Shop</h3>
<div class="paragraph">
<p>This subapp let a shop owner manage his shop. This include adding products, the store location, editing prices, emitting discounts, etc. Creating a presentation page in the platform.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-Brand">Brand</h3>
<div class="paragraph">
<p>This subapp let a brand navigate through the wallets it has published and create marketing products like coupons.<br></p>
</div>
<div class="paragraph">
<p>There will be a mechanism for the interaction between a brands and shops to associate in the use of marketing products.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-Retailer">Retailer</h3>
<div class="paragraph">
<p>TO BE COMPLETED</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-CryptoBroker">Crypto Broker</h3>
<div class="paragraph">
<p>This is a subapp focused for the use of brokers (people who buy and sell crypto currencies).<br>
The brokers are central actors in this platform.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-TopUpPoint">Top Up Point</h3>
<div class="paragraph">
<p>The idea is to let actors provide the service of selling crypto currency in exchange of fiat currency.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-CashOutPoint">Cash Out Point</h3>
<div class="paragraph">
<p>Similar to <a href="#Platform-SubApps-TopUpPoint">top up point</a>, this subapp let actors provide the service of buying crypto currency in exchange of fiat currency.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-Designer">Designer</h3>
<div class="paragraph">
<p>This subapp is initially intended to let developers contact user interface designers.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-Developer">Developer</h3>
<div class="paragraph">
<p>This subapp should let user contact the developers of their wallets.<br></p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-Marketer">Marketer</h3>
<div class="paragraph">
<p>TO BE COMPLETED</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="PlatformDescription-SourceCode">Source Code Distribution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fermat Platform is divided in three main subsystems.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Fermat-PIP</dt>
<dd>
<p><strong>P</strong>lug-<strong>i</strong>ns <strong>P</strong>latform. Basic components that bring essential functionality to the platform. This components are in general independent of the functionality to be implemented above the system.</p>
</dd>
<dt class="hdlist1">Fermat-P2P</dt>
<dd>
<p>Brings the network infrastructure</p>
</dd>
<dt class="hdlist1">Fermat-DMP</dt>
<dd>
<p><strong>D</strong>igital <strong>M</strong>oney <strong>P</strong>latform. This modules implement the tools for the <a href="#PlatformDescription-SubApps">subapplications</a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Each of this subsystem is divided in layers. Inside the layers we can find plug-ins, each plug-in has a specific responsability. As a convention we call the plug-ins inside Fermat-PIP Addons instead of Plug-ins.<br>
Plug-ins need to identify themself in order to ask for resources to addons. This is a security and organizational decision that helps the system organization as a whole.</p>
</div>
<div class="paragraph">
<p>We can also identify outside these subsystems two main structures. One is what we call fermat-api and the other is fermat-core.</p>
</div>
<div class="sect2">
<h3 id="_fermat_api">fermat-api</h3>
<div class="paragraph">
<p>The modules inside each layer define the necessary interfaces to accomplish their duty inside the plug-ins. However, this interfaces bring many times too much information to the developer. This is why we define a group of reduces interfaces to export to other layers. This interfaces among other definitions can be found in this module called fermat-pip-api.+
Some other definitions are for example exceptions and enums.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fermat_core">fermat-core</h3>
<div class="paragraph">
<p>This set of classes are the representation of the platform. The purpose of this modules is to initialize the whole system and to monitor the way the application is behaving.<br></p>
</div>
</div>
<div class="sect2">
<h3 id="_initialization_process">Initialization process</h3>
<div class="paragraph">
<p>The most intuitive way to initialize the platform is by creating an instance of each layer and then of each plug-in inside.+
So the sequence could be:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Platform -&gt; Layer -&gt; Plug-in</pre>
</div>
</div>
<div class="paragraph">
<p>One problem with this approach is that if we develop a new version of a plug-in tha needs more resources than the previous one, then there may be some devices that won&#8217;t be able to run the new version and would opt for the previous one.<br>
We would like that the platform could decide which version instantiate without the user having to indicate explicitly.<br>
This is why we defined a class named DeveloperBitDubai. The responsibility of this layer is to decide which version of a plug-in the platform should instantiate. Others developers will have there own Developer class to accomplish the same function.</p>
</div>
<div class="paragraph">
<p>The new initialization sequence would be:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Platform -&gt; Layer -&gt; Developer -&gt; Plug-in</pre>
</div>
</div>
<div class="paragraph">
<p>This works fine as long as we stay as the only developer for a plug-in. We could imagine that in the future a new developer would like to create it&#8217;s own version of an existing plug-in to offer to the platform.<br>
In this scenario we find again the problem we had for versions. Who decides which developer implementation we should select.
We created the PluginSubsystem class to solve this problem. The subsystem class instantiate the developer class and finally this developer class instantiate the version of the plug-in.</p>
</div>
<div class="paragraph">
<p>The final initialization sequence is therefore:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Platform -&gt; Layer -&gt; Subsysyem -&gt; Developer -&gt; Plug-in</pre>
</div>
</div>
<div class="sect3">
<h4 id="__end_of_fermat_documentations_platfomr_platformdescription_asciidoc">(END OF /fermat-documentations/platfomr/platformDescription.asciidoc)</h4>

</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fermat_pip_system_layers">Fermat-PIP System Layers</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_definitions_layer">Definitions Layer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>At the moment this layer provides definitions to the others layers like the list of all the crypto currencies supported by the platform, list of plug-ins, list of addons, etc.<br>
It also provides some standard implementations of common pieces of code like asymmetric encryption methods and currency conversion calculation methods.<br></p>
</div>
<div class="paragraph">
<p>Some folders and their description:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">crypto/asymmetric</dt>
<dd>
<p>Package that provide asymmetric encryption methods using eliptic curve cryptography.</p>
</dd>
<dt class="hdlist1">crypto/util</dt>
<dd>
<p>related classes for the asymmetric package implementation.</p>
</dd>
<dt class="hdlist1">developer</dt>
<dd>
<p>(<strong>draft of a</strong>) Class related to manage the information of a developer, like email, name and other information.</p>
</dd>
<dt class="hdlist1">event</dt>
<dd>
<p>We can also find the definition of the EventMonitor, PlatformEvent and DeasWithEventMonitor interfaces.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This classes may be relocated to the platform service layer.<br>
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1">diagrams/wallets</dt>
<dd>
<p><strong>classes with not quite clear purpose</strong></p>
</dd>
<dt class="hdlist1">enums</dt>
<dd>
<p>Enums that represent different lists like plug-ins, addons, crypto currencies, fiat currencies, etc.</p>
</dd>
<dt class="hdlist1">Money</dt>
<dd>
<p><strong>Containers classes (classes with setter and getters) for different data. Not entirely well implemented (for example, they use double to represent currency amounts instead of long)</strong></p>
</dd>
<dt class="hdlist1">util</dt>
<dd>
<p>Simple methods that may appear along the platform and should be implemented in a standard way like money conversion calculations.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_os_layer">OS Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_template_subtitle">Template Subtitle</h3>
<div class="paragraph">
<p>This is a template file</p>
</div>
</div>
<div class="sect2">
<h3 id="_plug_ins_in_this_layer">Plug-ins in this layer</h3>

</div>
<div class="sect2">
<h3 id="_database_system">Database System</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_device_location">Device Location</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_2">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_2">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_2">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_file_system">File System</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_3">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_3">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_3">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_platform_service_layer">Platform Service Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_template_subtitle_2">Template Subtitle</h3>
<div class="paragraph">
<p>This is a template file</p>
</div>
</div>
<div class="sect2">
<h3 id="_plug_ins_in_this_layer_2">Plug-ins in this layer</h3>

</div>
<div class="sect2">
<h3 id="_location_subsystem">Location Subsystem</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_4">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_4">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_4">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_error_manager">Error MAnager</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_5">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_5">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_5">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_event_manager">Event Manager</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_6">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_6">Version 1</h5>
<div class="sect5">
<h6 id="_plug_in_description">Plug-in Description</h6>
<div class="paragraph">
<p>Along the system many modules use events to communicate specific information of the state of the platform. For example, there is an event to communicate a variation in the exchange rate of a crypto currency, another event informs when a user logs in, etc.<br>
For each event we can define a corresponding component called <strong>event listeners</strong> which will be informed every time the event occurs.
The event manager is the plug-in responsable of receiving the events thrown by the system and inform them to the event listeners.</p>
</div>
<div class="paragraph">
<p>An event listeners have a reference to a module called <strong>event handlers</strong> which is the component invoked to react when an event occur.<br>
The event handler try to execute an action when he is invoke by the listener. This action can possibly fail and throw an exception (java exception). However, as we said before, events have an informative role so it is not correct for the system to throw an exception to the event listener who invoked the handler neither to the module that threw the event.<br>
To solve this problem, the event listener catch the exception and gives it to a component called <strong>event monitor</strong> which register the exceptions and inform the platform.<br>
We expect that in the future the platform will be able to make decisions according to the information provided by the event monitor.s</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hardware_layer">Hardware Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_template_subtitle_3">Template Subtitle</h3>
<div class="paragraph">
<p>This is a template file</p>
</div>
</div>
<div class="sect2">
<h3 id="_plug_ins_in_this_layer_3">Plug-ins in this layer</h3>

</div>
<div class="sect2">
<h3 id="_local_device">Local Device</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_7">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_7">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_6">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_user_layer">User Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_template_subtitle_4">Template Subtitle</h3>
<div class="paragraph">
<p>This is a template file</p>
</div>
</div>
<div class="sect2">
<h3 id="_plug_ins_in_this_layer_4">Plug-ins in this layer</h3>

</div>
<div class="sect2">
<h3 id="_device_user">Device User</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_8">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_8">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_7">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_extra_user">Extra User</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_9">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_9">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_8">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_intra_user">Intra User</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_10">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_10">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_9">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_license_layer">License Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_template_subtitle_5">Template Subtitle</h3>
<div class="paragraph">
<p>This is a template file</p>
</div>
</div>
<div class="sect2">
<h3 id="_plug_ins_in_this_layer_5">Plug-ins in this layer</h3>

</div>
<div class="sect2">
<h3 id="_plug_in">Plug-in</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_11">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_11">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_10">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_wallet">Wallet</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_12">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_12">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_11">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fermat_p2p_system_layers">Fermat-P2P System Layers</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="Fermat-P2P-CommunicationLayer">Communication Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_layer_description">Layer Description</h3>
<div class="paragraph">
<p>At the moment of the creation of this document the communication layer is the main (and only) layer inside Fermat-P2P subsystem.<br></p>
</div>
<div class="paragraph">
<p>This layer give the communication services to the upper layers.<br>
A distinguished difference between this layer and others in Fermat system is that this is the first layer that interact with upper layers as a whole and not as plug-ins, i.e. plug-ins that need communication services ask them to the layer interface and not to the plug-ins inside.<br>
Even more, a purpose of this layer is to abstract completely the plug-ins managing the real connection The upper layers should not be aware of the technology in use (wi-fi, NFC, p2p, bluetooth, etc.) and problems related to a connection should be solved by the communication layer without disturbing the clients.<br></p>
</div>
</div>
<div class="sect2">
<h3 id="Fermat-P2P-CommunicationLayer-CloudServer-Connection-Technologies">Connection technologies</h3>
<div class="sect3">
<h4 id="_cloud">Cloud</h4>
<div class="paragraph">
<p>In this first implementation will rely in a cloud server. At initialization the devices will contact through the cloud client plug-in with the server to inform they are online and can be contacted by other users.<br></p>
</div>
<div class="paragraph">
<p>There is an identification system that identify devices, actors and <a href="#Fermat-DMP-NetworkServiceLayer">network services</a> that consist in pairs of keys generating by asymmetric cryptography methods.<br></p>
</div>
</div>
<div class="sect3">
<h4 id="_p2p">P2P</h4>
<div class="paragraph">
<p>In the future we intend to move our communication infrastructure to a peer-to-peer architecture. This will bring both many challenges and advantages. For example, if we rely in a server or group of servers attacks to the service could be focused on the server.<br></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_plug_ins_in_this_layer_6">Plug-ins in this layer</h3>
<div class="paragraph">
<p>Plug-ins in this layer essentially consist on the modules needed for the implementation of the communication protocols and interfaces for the different <a href="#Fermat-P2P-CommunicationLayer-CloudServer-Connection-Technologies">connection technologies</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cloud_client">Cloud Client</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_13">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_13">Version 1</h5>
<div class="sect5">
<h6 id="_plug_in_description_2">Plug-in Description</h6>

</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cloud_server">Cloud Server</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_14">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_14">Version 1</h5>
<div class="sect5">
<h6 id="_plug_in_description_3">Plug-in Description</h6>

</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fermat_dmp_system_layers">Fermat-DMP System Layers</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="Fermat-DMP-NetworkServiceLayer">Network Service Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_layer_description_2">Layer Description</h3>
<div class="paragraph">
<p>The plug-ins in this layer are the ones that let the functionality of the platform transcend a single device to let different users interact with each other over the platform. This layer is the main consumer of the <a href="#Fermat-P2P-CommunicationLayer">communication layer</a> services.<br></p>
</div>
<div class="paragraph">
<p>The modules in the world layer also implement interaction with entities that live outside the device, but in that layer the components we interact with live outside the platform.<br></p>
</div>
<div class="paragraph">
<p>There are some common patterns in the way all the network services (the plug-ins in this layer) act.<br>
Let&#8217;s say we have two devices A and B and a network service that is implemented in both devices. The network service implementations will communicate as pairs, i.e. the  network service implementation of A will interact directly (in a logical way) to the  implementation in B and vice versa. Physically the communication will be conducted trough the communication layer but the components will interact as if they where talking directly to each other (as if they were in the same device).<br></p>
</div>
<div class="paragraph">
<p>To implement this, each plug-in (network service) has two special classes. One represent the local network service and the other represent the remote network service.<br>
The remote network service class internally has a connection provided by communication layer. When two devices A and B interact trough a network service we have this imageMiddleware:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>       Device A           Device B
    +-------------+    +-------------+
    | +---------+ |    | +---------+ |
    | |  Local  | |    | | Remote  | |
    | | Network |========| Network | |
    | | Service | |    | | Service | |
    | +---------+ |    | +---------+ |
    |      *      |    |      *      |
    |      *      |    |      *      |
    |      *      |    |      *      |
    | +---------+ |    | +---------+ |
    | | Remote  | |    | |  Local  | |
    | | Network |========| Network | |
    | | Service | |    | | Service | |
    | +---------+ |    | +---------+ |
    +-------------+    +-------------+

 Reference:
      ====  connection
      ****  interaction</pre>
</div>
</div>
<div class="paragraph">
<p>Network services have a pair of cryptography asymmetric keys. They use this keys to identify themself and sign the messages they communicate through the network.</p>
</div>
</div>
<div class="sect2">
<h3 id="_plug_ins_in_this_layer_7">Plug-ins in this layer</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_basic_wallet_layer">Basic Wallet Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_layer_description_3">Layer Description</h3>
<div class="paragraph">
<p>&#8230;</p>
</div>
</div>
<div class="sect2">
<h3 id="_plug_ins_in_this_layer_8">Plug-ins in this layer</h3>

</div>
<div class="sect2">
<h3 id="_discount_wallet">Discount Wallet</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_15">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="BasicWallet-DiscountWallet-BitDubai-V1">Version 1</h5>
<div class="sect5">
<h6 id="_plug_in_description_4">Plug-in Description</h6>
<div class="paragraph">
<p>The main purpose of this plug-in is to provide an abstraction that let
the user manipulate fiat money.<br>
The important aspect is that in reality this plug-in is managing the
value in a crypto currency. This means that the user will always see his
money in his local country currency being totally transparent to him the
crypto currency representation.</p>
</div>
</div>
<div class="sect5">
<h6 id="_main_problems_the_plug_in_deals_with">Main Problems the Plug-in deals with</h6>
<div class="paragraph">
<p>The implementation of this kind of abstraction carry many technical
problems which we will discuss in this section.<br>
We will explain the factors involved and in the next sections we will
present the way the plug-in deals with this considerations. For
simplicity from now on we will assume that our local currency are USD
(US Dollars) and the crypto currency involved is BTC (Bitcoins).</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Exchange rate fluctuation</strong><br>
When dealing with different currencies we have an exchange rate involved
that varies from day to day. This characteristic is no stranger to
crypto currencies.<br>
With this consideration in mind, suppose that the user deposits in his
Discount Wallet 100 dollars and that the Bitcoin/Dollar exchange rate is
1BTC per 100USD. This means that the wallet internally will have a value
of 1 BTC and the user will see that he has 100 USD.<br>
Now, how should we act if the next day the Bitcoin/Dollar rate is:</p>
<div class="ulist">
<ul>
<li>
<p>1 BTC per 50 USD. This would mean that the value inside the wallet is
now 50 USD (and not the 100 USD the user deposited and still assumes he
has).</p>
</li>
<li>
<p>1 BTC per 200 USD. This would mean that the value inside the wallet
is now 200 USD (and not the 100 USD the user deposited and still assumes
he has).</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Deposits with different exchange rates</strong><br>
How should we act if the user deposits money in the discount wallet in
several moments at different exchange rates?</p>
</li>
<li>
<p><strong>Extractions</strong><br>
Imagine the user deposited 100USD at a rate of 1BTC per 100USD and then
deposited another 100USD but now with a rate of 1BTC per 50USD. If the
user then wants to extract 200USD from his discount wallet, how should
we respond?</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_plug_in_s_business_logic">Plug-in&#8217;s Business Logic</h6>
<div class="paragraph">
<p>Let&#8217;s answer to the questions pointed before. For convenience we will
answer the second one first.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Deposits with different exchange rates</strong><br>
We will manage this by saving the information of the exchange rate
associated to every deposit made with two tables. The first table will
deal with the registration of the credits (we will use the word credit
as synonym of deposit). This table will have a reference to what we will
call a <strong>value chunk</strong>. A value chunk is a record that tell us (between a
few other things):</p>
<div class="ulist">
<ul>
<li>
<p>The amount of fiat currency deposited by the credit operation.</p>
</li>
<li>
<p>The equivalent in crypto currency amount at that moment (this crypto
amount is what we saved as value, the fiat amount is kept as reference
of the exchange rate).</p>
</li>
<li>
<p>The state of the value chunk, at the moment of the credit it will be
created as UNSPENT. This field can also be SPENT or FATHER (we explained
their uses later)</p>
<div class="paragraph">
<p>So, initially every credit record in the Credits table will have a value
chunk assign in the ValueChunk table.</p>
</div>
<div class="paragraph">
<p>Now lets see how we use this information to treat the other issues.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Exchange rate fluctuation</strong><br>
The idea is to show the user two amounts of money, one called <strong>balance
of the wallet</strong> and the other called <strong>available amount</strong> both measured in
fiat currency units.<br>
The <strong>balance of the wallet</strong> (or simply <strong>balance</strong>) is calculated as the
sum of fiat money the user has deposited minus the sum of what he has
spent (always in fiat currency units).<br>
The <strong>available amount</strong> will represent what the user can safely spend and
its calculation is the core of this plug-ins business logic.<br>
Lets make some more precise definitions in order to define this
amount.</p>
<div class="paragraph">
<p>As we explained before, we have records saved with the information about
every deposit made. The value chunks have the information about the
crypto currency amounts we have deposited, the amount of fiat
currency we used to get that crypto and a state field.<br>
Then, we can represent a value chunk with a tuple (<em>fa</em>,<em>ca</em>,<em>s</em>) where <em>fa</em> is the
fiat currency amount registered in the record, <em>ca</em> is the crypto
currency amount registered in the record and <em>s</em> is the current state of
the record. We are ignoring other data in the representation for the
purpose of the explanation.</p>
</div>
<div class="paragraph">
<p>Now, let (fa_1 , ca_1 , s_1), &#8230; ,(fa_n , ca_n , s_n) be all the value
chunks and let currentFiatAmount be a function that tells us the
equivalent fiat amount of money represented by the crypto amount we give
it as parameter.<br>
If the current rate is 1BTC per 100USD then
currentFiatAount(1) is equal to 100. You can see that at the moment of
the creation of a value chunk (<em>fa</em>,<em>ca</em>) it holds that
currentFiatAmount(<em>ca</em>) = <em>fa</em>.</p>
</div>
<div class="paragraph">
<p>So, with this definitions made we can define with precision the balance
and available amount as follow:<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p>balance is the sum of all the fa_i that correspond to the value
chunks with state UNSPENT.</p>
</li>
<li>
<p>available amount will be the <strong>minimum between</strong> balance and the sum of
currentFiatAmount(ca_i) for the unspent chunks created with an exchange
rate below the current one, i.e. the values chunks where it holds that
currentFiatAmount(ca_i) &gt;= fa_1 and also s = UNSPENT.<br>
<strong>The user will never see an available amount superior to the balance he
has</strong> (this is a convention we took in this wallet, this could change in
other kind of wallets).</p>
<div class="paragraph">
<p>Let&#8217;s see this with some examples:<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Example 1:</strong><br>
Suppose you deposited 100USD in your Discount Wallet and that the
exchange rate at that moment was 1BTC per 100USD. In this situation you
will see that balance = available amount = 100USD and as a user you
won&#8217;t see you have really 1BTC.<br>
There will be one record in the Credits table and a value chunk
(100USD,1BTC,UNSPENT) in the ValueChunk table.<br>
Now imagine that the
exchange rate change to 1BTC per 50USD. Under this new situation you
will see balance = 100USD and an available amount of 0USD, because there
is only one ValueChunk and 50 = currentFiatAmount(1) &lt; 100.<br>
 Finally imagine that the new exchange rate is 1BTC per 200USD, Under
this situation you will see again that balance = available amount =
100USD.</p>
</li>
<li>
<p><strong>Example 2:</strong><br>
 Suppose you make two separate credits of 100USD at a rate of 1BTC per
200USD.<br>
 We will see balance = available amount = 200USD. Also two records in
the Credits record and two value chunks like (100USD,0.5BTC,UNSPENT).<br>
 Now imagine the rate drops to 1BTC per 50USD. In this situation balance = 200USD and the available amount is 0USD.<br>
 At this point, suppose we deposit another 100USD, this will add a
record to the Credits table an the value chunk (100USD, 2BTC,UNSPENT) to
the ValueChunks table. The refresh balance would be 300USD and the
available amount would be just 100USD.<br>
 Finally imagine that the rate raise up to 1BTC per 100USD. The only
chunk with currentFiatAmount(ca) &gt;= fa is the last chunk we added. So
the balance is still 300 and the available amount would be
currentFiatAmount(2) which in this case is 200USD.<br></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Extractions</strong><br>
So, our last issue deals with the way we will manage the information we
have in respect to the debits of this wallet (we will use debit as a
synonym of extraction).<br>
If the user wants to spend a fiat amount of money, say N, we check two conditions. First we check if N &gt;= 0 and then if available amount &gt;= N.<br>
If this conditions hold we add a record to a Debits table similar to the
one described for Credits table.<br>
Now, as we have saved crypto currency as value and the user wants to
spend fiat currency the big questions are:<br></p>
<div class="olist arabic">
<ol class="arabic" start="1">
<li>
<p>how much do we subtract to the available amount and to the balance?<br>
Remember that the exchange rate of the currencies changes with time and
some chunks where created at a lower rate than the actual.<br>
This means that we bought the crypto currency at a value and now this crypto amount
represent more fiat money that what we paid initially.<br>
For example, if you deposited 100USD at a rate of 1BTC per 100USD and
the exchange raise to 1BTC per 200USD you will see a balance and
available amount of 100USD, but the value inside the wallet is 1BTC
which is at the moment equivalent to 200USD.<br>
Under the logic of this wallet if you try to spend 100USD you will be
notified at the moment of paying that you have a discount of 50USD in
this case.<br>
This discount is possible because you can pay the purchase using 0.5BTC (equivalent to 100USD now but obtained at a price of 50USD). Then, the discount will be
getCurrentFiatAmout(0.5) - oldFiatValue(0.5), where oldFiatValue tells
you the equivalent amount of fiat currency that its parameter represent
using the exchange rate of the value chunk (this may be a different rate
than the actual rate as happens in this example).
We would keep a value of 0.5BTC which still represent the remaining original 50USD. The user don&#8217;t need to know this internal mechanism but can benefit from it.<br>
<strong>NOTE:</strong> One good question is, why the user does not get a discount of
100USD instead of 50USD? This will be answered in the next paragraphs.<br></p>
</li>
<li>
<p>The second question is how do we manage the value chunks to keep the
integrity of the ValueChunks, Debits and Credits tables and be able to
apply this strategy of discounts?<br>
In the example explained before the value chunk stored of (100USD,
1BTC, UNSPENT) must be changed. We will do this by changing it state to
FATHER and therefore keep in the ValueChunks table the record (100USD,
1BTC, FATHER) representing that it was partially spent and we will also
add two new (children) records. One of the children will be (50USD,
0.5BTC, SPENT) representing the fraction of the original chunk used to
pay the debit. For the other chunk we have two options:</p>
<div class="ulist">
<ul>
<li>
<p>One is to store (50,0.5,UNSPENT) representing the money kept. In this
case, note that the chunk fiat amount is equivalent to the crypto amount
calculated at the <strong>original father value chunk rate</strong> and not the actual
rate. This would be intuitively thought as if we have just extracted the
100USD needed to pay (using 0.5BTC underneath) and kept the rest without
touching it.<br></p>
</li>
<li>
<p>As an alternative, we could store as second child value chunk
(100,0.5,UNSPENT), i.e. calculating the fiat amount at the <strong>actual
exchange rate</strong> instead of the father&#8217;s original rate. We can think this
intuitively as if we have extracted the 200USD of value we had, then
paid the 100USD needed and then deposited back the remaining 100USD at
the actual exchange rate.</p>
<div class="paragraph">
<p>The difference of this two strategies is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the second strategy, you will have an apparent higher discount
(because you will have 100USD to add to the balance instead of just
50USD coming from the UNSPENT child chunk), you will also see an
available amount of 100USD instead of 50USD.<br>
The disadvantage is that if the exchange rate goes down, say to 1BTC per
150USD, the value chunk will not be available until the rate go back to
1BTC per 200USD or higher.</p>
</li>
<li>
<p>In the first approach (the one we followed in this implementation)
the value chunk will be available for the case of the rate going down to
1BTC per 150USD. So you still can have a discount in the future with the
chunk. The main advantage is that at this rate you will have this chunk
available for a debit.<br>
The disadvantage is that the discount will probably be lower and the
lower balance of the wallet will restrict the available amount to spend.</p>
<div class="paragraph">
<p>Our conclusion is that real day to day use should provide the
information to decide which approach is the best. For now, we will take
the one described first.</p>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>So, let&#8217;s try to formalize the algorithm to implement this logic. We need
to calculate the discount and to modify the ValueChunks table to reflect
the debit in the way explained answering the question 2.</p>
</div>
<div class="paragraph">
<p>Lets begin as usual with some definitions used in the algorithm:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>amount to spend: N<br></p>
</li>
<li>
<p>actual value chunk being analysed: vc, we will use the notation that
vc is the tuple (fa,ca,state) where:</p>
<div class="ulist">
<ul>
<li>
<p>fa is the fiat amount of the value chunk<br></p>
</li>
<li>
<p>ca is the crypto amount of the value chunk<br></p>
</li>
<li>
<p>state is the state of the value chunk<br></p>
</li>
</ul>
</div>
</li>
<li>
<p>The discount acumulated: discount (initialy set to 0)</p>
</li>
<li>
<p>getCurrentFiatAmount: a function that given a crypto amount of
currency it returns the equivalent fiat amount at <strong>the current</strong> exchange
rate.</p>
</li>
<li>
<p>getCurrentCryptoAmount: a function that given a fiat amount of
currency it returns the equivalent crypto amount at <strong>the current</strong>
exchange rate.</p>
</li>
<li>
<p>oldFiatValue: a funtion that given a crypto amount of currency, it
returns the equivalent fiat amount calculated at the <strong>original father
chunk exchange rate</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Now we can write the algorithm</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Check that N &gt;= 0, if not we end the execution with an error message</p>
</li>
<li>
<p>Check that the available amount &gt;= N, if not end the execution with
an error message</p>
</li>
<li>
<p>Take the chunks from the ValueChunks table with state UNSPENT and
store them in a list.</p>
</li>
<li>
<p>Sort the chunks of the list putting the chunks generated at lower
exchange rate at the beginning of the list. The exchange rate of a chunk
(fa,ca,state) is equal to the quotient fa/ca.</p>
</li>
<li>
<p>Now iterate over this sorted list until you N is 0 (this condition
will eventually hold because of the steps 1 and 2). Inside this loop
proceed as follow:</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre>         if(N &gt;= getCurrentFiatAmount(ca))
             N = N - getCurrentFiatAmount(ca)
             discount = discount + (getCurrentFiatAmount(ca) - fa)
             vc = (fa,ca,SPENT) // vc state is updated to SPENT
         else
             let
                  ca1 = getCurrentCryptoAmount(N)
                  ca2 = ca - ca1
                  fa1 = oldFiatValue(ca1) // the amount represented by ca1
                                          // calculated at the original father's rate
                  fa2 = oldFiatValue(ca2) // the amount represented by ca2
                                          // calculated at the original father's rate
             in
                  vc = (fa,ca,FATHER) // vc state is updated to PARENT

                  // We add two new value chunks vc1 and vc2
                  // to the ValueChunks table (the children of vc)
                  vc1 = (fa1 , ca1 , SPENT)
                  vc2 = (fa2 , ca2 , UNSPENT)
                  discount = discount + (getCurrentFiatAmount(ca1) - oldFiatValue(ca1))
                  N = 0
             end // end of let
         end // end of if-else</pre>
</div>
</div>
<div class="paragraph">
<p>Here we finished the explanation behind the business logic of this
module. The rest of this document talks about the source code structure
and implementation issues. During this explanation we have simplified
some details to make the ideas clearer. Some of this details that we
should remark are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The crypto currency can be different from Bitcoin, but a single wallet
will work with only one type of crypto currency from the beginning of it
existence to the end.</p>
</li>
<li>
<p>The same observation holds for fiat currency. A wallet can use other
currencies different than the US dollar but it will manage only one kind
of fiat currency.</p>
</li>
<li>
<p>The fiat and crypto currency amounts are represented in long integers
to avoid trouble with the precision of floating point representation.
For example, 1 USD is stored as 1000 thousandths of a dollar, and 1BTC
is stored as 100.000.000 units called satoshis. In this way we avoid
dealing with decimals in many (but unfortunately not all) calculations.</p>
</li>
<li>
<p>The tables described (Credits, Debits and ValueChunks tables) have a
few more data than mentioned.</p>
</li>
<li>
<p>The functions presented for conversions between fiat and crypto
currencies have more parameters than explained and slightly different
names too.</p>
</li>
<li>
<p>In the actual implementation the conversions will probably bring
decimals to the currencies representations. This must be treated with
care. So we will see in the actual code conversion functions that round
decimals up and down applied depending on the convenience of the
situation. The next section will explain those decisions and some
improvement to the implementation of this algorithm. The rule of thumb
to follow in this module is: No matter what is the problem, <strong>always keep
a consistent relation between the balance, available amount and internal
information stored in the wallet</strong>.<br>
For more information about the conversions functions see their
documentation in the Definitions Layer</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_implementation_notes">Implementation Notes</h6>
<div class="paragraph">
<p>In this section we try to explain how we can refine the specification
given on the previous section and treat some of its problems.<br>
The main problem to notice is that in the case of a debit, we will have
to update the ValueChunks table. If we consume an entire value chunk it
does not bring any apparent problem (we just need to mark the chunk as
SPENT). But, there is a possibility that we may need to spend only part
of a chunk and that will bring the creation of two new value chunks. The
problem with this is that in our implementation for a chunk (fa,ca,s) we
have fa and ca (the fiat amount and crypto amount of the chunk
respectively) represented as long integers, but despite the conversion
functions (getCurrentFiatAmount, oldFiatValue, etc.) will give us a long
integer, that integer will be an approximation of the real value (i.e.
the long will possibly lose the decimals of the real result of the
conversion).</p>
</div>
<div class="paragraph">
<p>This means that we will probably need to deal on how to manage those
decimal "lost". Lets attack this problem.</p>
</div>
<div class="paragraph">
<p>In the implementation we have as a parameter the crypto amount that is
the equivalent to N, lets call it cryptoToPay. A good idea would be to
reduce (or eliminate) the application of this error problematic methods,
lets see if we can use cryptoToPay to achieve this goal.</p>
</div>
<div class="paragraph">
<p>In the first branch of the if statement we have three uses of
getCurrentFiatAmount.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>         if(N &gt;= getCurrentFiatAmount(ca))
             N = N - getCurrentFiatAmount(ca)
             discount = discount + (getCurrentFiatAmount(ca) - fa)
             vc = (fa,ca,SPENT) // vc state is updated to SPENT</pre>
</div>
</div>
<div class="paragraph">
<p>We need a long integer in the three appearances of the function. First,
We can replace the if condition N &gt;= getCurrentFiatAmount(ca) with the
precise one cryptoToPay &gt;= ca.</p>
</div>
<div class="paragraph">
<p>Now we could round down the other two numbers. This would imply that we
will tell the user that the discount was lower than what it really was,
although this does not harm the integrity of the information stored it
is not the best solution and also bring other issues like problems with
the else branch of this if statement.<br>
So, the better solution is to not only stop accumulating the discount,
but also avoid subtracting to N an inaccurate amount (now the if
condition is based on cryptoToPay, so we don&#8217;t need to modify N any
more). We will instead just add up the fiat amounts of the chunks used
to pay and simply calculate the discount as N - spent, where spent
represent the result of the said sum. With this modifications and adding
the line cryptoToPay = cryptoToPay - ca, the implementation version of
this branch will be</p>
</div>
<div class="listingblock">
<div class="content">
<pre>         if(cryptoToPay &gt;= ca)
             cryptoToPay = cryptoToPay - ca
             spent = spent + fa
             vc = (fa,ca,SPENT) // vc state is updated to SPENT</pre>
</div>
</div>
<div class="paragraph">
<p>In the else branch of the if statement we will need more care.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>         else
             let
                  ca1 = getCurrentCryptoAmount(N)
                  ca2 = ca - ca1
                  fa1 = oldFiatValue(ca1)
                  fa2 = oldFiatValue(ca2)
             in
                  vc = (fa,ca,FATHER) // vc state is updated to PARENT
                  // We add two new value chunks vc1 and vc2
                  // to the ValueChunks table (the children of vc)
                  vc1 = (fa1 , ca1 , SPENT)
                  vc2 = (fa2 , ca2 , UNSPENT)
                  discount = discount + (getCurrentFiatAmount(ca1) - oldFiatValue(ca1))
                  N = 0
             end // end of let</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>We can avoid using getCurrentCryptoAmount to calculate ca1 and simply
write ca1 = cryptoToPay.<br></p>
</li>
<li>
<p>The discount line can be deleted as mentioned before.<br></p>
</li>
<li>
<p>fa2 can be calculated as fa2 = fa - fa1.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So now we only have only one tricky method application instead of the
original 8. How should we deal with this one? If we round down the user
will see a higher discount and we will alter a little bit the exchange
rate of vc2. The opposite will happen if we round up the result of
oldFiatValue(ca1). In both cases the balance of the wallet will stay
consistent, so we choose to simply round down the number.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This approach "simulates" that we have "created
money", and is important to think about this. The "real money" is what
has value, and the value in this wallet is the crypto currency (which we
haven&#8217;t rounded, not even once). This extra amount of fiat money added
to the balance won&#8217;t bring any problem because it won&#8217;t be available to
spend until exchange rate increase proportionally in order to pay for
the increased amount, i.e. if we call the increased amount produced by
the rounding increasedAmount we have that the second child chunk vc2
ends up being (oldFiatValue(ca2) + increasedAmount , ca2 , UNSEPENT),
and to be considered as part of the available amount the exchange rate
needs to go up in order to satisfy getCurrentFiatAmount(ca2) &gt;=
oldFiatValue(ca2) + increasedAmount, so the increasedAmount will be
covered by real value.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The final approach of the implementation will then be (steps 1 and 2 can
still use N):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Check that N &gt;= 0, if not we end the execution with an error message</p>
</li>
<li>
<p>Check that the available amount &gt;= N, if not end the execution with an error message</p>
</li>
<li>
<p>Take the chunks from the ValueChunks table with state UNSPENT and store them in a list.</p>
</li>
<li>
<p>Sort the chunks of the list putting the chunks generated at lower exchange rate at the beginning of the list. The exchange rate of a chunk (fa,ca,state) is equal to the quotient fa/ca.</p>
</li>
<li>
<p>Now iterate over this sorted list until you cryptoToPay is 0 (this condition will eventually hold because of the steps 1 and 2). Inside this loop proceed as follow:</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre>         if(cryptoToPay &gt;= ca)
             cryptoToPay = cryptoToPay - ca
             spent = spent + fa
             vc = (fa,ca,SPENT) // vc state is updated to SPENT
         else
             let
                  ca1 = cryptoToPay
                  ca2 = ca - ca1
                  fa1 = oldFiatValueRoundedDown(ca1)
                  fa2 = fa - fa1
             in
                  vc = (fa,ca,FATHER) // vc state is updated to PARENT
                  // We add two new value chunks vc1 and vc2
                  // to the ValueChunks table (the children of vc)
                  vc1 = (fa1 , ca1 , SPENT)
                  vc2 = (fa2 , ca2 , UNSPENT)
                  cryptoToPay = 0
                  spent = spent + fa1
             end // end of let</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic" start="6">
<li>
<p>Outside the loop, calculate the discount as</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre>            discount = N - spent</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_possible_improvements_and_other_considerations">Possible improvements and other considerations</h6>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Notice that the only chunk that could be partially spent is the last
chunk used to pay the credit, i.e. the one where</p>
<div class="paragraph">
<p>N &lt; getCurrentFiatAmount(ca) or more precisely cryptoToPay &lt; ca</p>
</div>
<div class="paragraph">
<p>So, we would like to avoid or at least minimize the occurrence of this
situation. Under this idea, a good strategy would be that given a
deposit of an amount fa of fiat currency and its corresponding amount ca
of crypto currency, instead of storing one value chunk (fa,ca,UNSPENT)
we can add k chunks of the form (fa/k,ca/k,UNSPENT) where k = gcd(ca,fa)
(greatest common divisor of ca and fa).</p>
</div>
</li>
<li>
<p>The last idea will put many "identical" chunks in the
ValueChunksTable. We can improve the representation by adding a field to
the chunk that tells the number of chunks with this values i.e. store
(fa/k, ca/k , UNSPENT , k) with k = gcd(ca,fa) instead of k chunks
(ca,fa,UNSPENT).</p>
</li>
<li>
<p>We should consider the effect of reducing the size of the numbers
with strategies like the one described with respect to the rounding
errors brought by the conversion methods.</p>
</li>
<li>
<p>We can implement the second alternative mentioned about how to
refresh the ValueChunksTable when we have to break a chunk to spend it.
We could even let an agent change the strategy dynamically.</p>
</li>
</ol>
</div>
</div>
<div class="sect5">
<h6 id="_todo_and_other_notes">TODO and Other Notes</h6>
<div class="ulist">
<div class="title">Think</div>
<ul>
<li>
<p>Cada cuanto se actualiza el index the intercambios?</p>
</li>
<li>
<p>qu hacer si entre la consulta sobre el descuento y la compra efectiva la tasa de cambio vara? Esto podra verse como algo raro en la Discount Wallet.</p>
</li>
<li>
<p>En la actualizacin de las tablas al romper un chunk.
Le coloco que el credit que cre a los hijos es el del padre o lo dejo null?</p>
</li>
<li>
<p>Precios de compra y de venta, interfaz de CryptoIndexManager</p>
</li>
<li>
<p>Qu significa el timestamp de un value chunk?
Si es el momento de creacin entonces hay que cambiar que en el debit que
implement no se modifique el timestamp de los value chunks originales</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">TODO</div>
<ul>
<li>
<p>All the logic described here is already implemented.</p>
</li>
<li>
<p>To finish the implementation we need to correct the pluginRoot, also
the databaseFactory (it should try to open the database before creating
it)</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_discount_wallet_2">Discount Wallet</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_16">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="BasicWallet-BitcoinWallet-BitDubai-V1">Version 1</h5>
<div class="sect5">
<h6 id="_plug_in_description_5">Plug-in Description</h6>
<div class="paragraph">
<p>Como las dems wallets de la capa de Basic Wallet, este plugin lleva el balance de su niche wallet asociada.<br>
En este caso el balance puede fragmentarse en dos conceptos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Available Balance: Es la cantidad de bitcoins que el usuario tiene disponible en el momento para
manipular (gastar).</p>
</li>
<li>
<p>Book Balance: Es la cantidad de bitcoins que estn siendo manejadas por la wallet.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El book balance puede diferir temporalmente del available balance. Por ejemplo, cuando llegan bitcoins a
una wallet, la red bitcoin nos avisa de la llegada de crypto currency apenas se ve en la red una
transaccin que se dirige a nuestra wallet. Sin embargo, hasta que la transaccin no entra en un bloque
no tenemos forma de utilizar estos bitcoins. Queremos que el usuario pueda ver que la transaccin se est
procesando por la red y actualizarle su balance, pero al mismo tiempo queremos impedir que pueda gastarlo.<br>
El procedimiento para este tipo de situacin en un sistema contable es registrar en el book balance estos bitcoins
detectados que an no se confirmaron y luego de que entren en un bloque sean ingresados al available balance.<br>
En el perodo de tiempo entre que se identifica la transaccin entrante y se confirma por la red, tendremos que el
book balance tendr ms bitcoins que el available balance.<br>
Otro ejemplo sobre las situaciones en que estos dos balances difieren es al momento de hacer un dbito.<br>
Cuando enviamos un dbito, este ser descontado del available balance y no se descontar del book balance hasta que
no se confirme el envo exitoso de la transaccin.<br></p>
</div>
<div class="paragraph">
<p>Por lo tanto, esta wallet deber permitirnos manejar crditos (ingresos), dbitos (egresos) y consultas de balance
de ambos tipos de balances.<br></p>
</div>
<div class="paragraph">
<p>A nivel del sistema, la modificacin al book balance y la modificacin al available balance son dos
transacciones distintas. La wallet deber llevar una lista de todas las transacciones que se realizan
(sean del book balance o del availbable balance).<br></p>
</div>
<div class="paragraph">
<p>Notemos entonces que como vamos a tener una tabla de transacciones, requeriremos que la clave primaria
de la misma ya no sea el hash de la transaccin bitcoin asociada, sino un UUID diferente.<br>
Analicemos esto con un ejemplo:</p>
</div>
<div class="paragraph">
<p>Una transaccin entrante es detectada por el mdulo de la red bitcoin, los mdulos transaccionales
son notificados por la red y aplican en el book balance la transaccin correspondiente asociada
a esta transaccin bitcoin entrante.<br>
Unos minutos ms tarde, llega un aviso de la red bitcoin comunicando que la transaccin fue confirmada,
por lo que los mdulos transaccionales aplican en el available balance la actualizacin correspondiente.<br>
Notemos que en la tabla de las transacciones se ingresarn dos registros para la misma transaccin bitcoin,
el que registr la identificacin de la transaccin y el que refistr su confirmacin.<br>
Ambas transacciones (de fermat, es decir, registros de la tabla de transacciones de la bitcoin wallet)
estn asociadas a la misma transaccin bitcoin, es por esto que no podemos usar el hash de la transaccin
bitcoin como clave primaria de la tabla de transacciones.</p>
</div>
<div class="paragraph">
<p>Por cuestiones de optimizacin queremos que el clculo de ambos balances se lleve en una tabla de la
base de datos del plugin. Esta tabla tendr dos columnas, una para el Book Balance y otra para el
Available Balance.<br>
Cuando se haga un dbito/crdito en alguno de los balances se restar/sumar el monto a estos valores
que estn en la tabla. La tabla siempre tendra un unico registro<br></p>
</div>
<div class="paragraph">
<p>Por otro lado, en la tabla de transacciones, queremos llevar dos valores de informacin ms. Estos valores
sern el Running Book Balance y el Running Available Balance, los cuales registran los balances acumulados
hasta el momento de la transaccin.<br>
Por ejemplo, si tenamos 2 BTC en el Book Balance y la misma cantidad en el Available Balance y se ejecuta
el mtodo de credit sobre el Book Balance registrando el ingreso de 1 BTC tendremos que en el campo de Running
Book Balance figurarn 3 BTC mientras que en el de Running Available Balance dir 2 BTC.<br>
Si luego entra otra transaccin al Book Balance de 2 BTC, se ingresar la nueva transaccin con valores de
Running Book Balance de 5 BTC y el Running Available Balance seguir siendo de 2 BTC.<br>
Cuando se ejecute el credit del Available Balance para alguna de estas transacciones, se ingresara una
treansaccion que tendr como Running Book Balance el Book Balance actual y como Available Book Balance
el Available Book Balance actual ms el monto de la transaccin crypto asociada.<br></p>
</div>
</div>
<div class="sect5">
<h6 id="_plug_in_structure">Plug-in Structure</h6>
<div class="paragraph">
<p>La estructura de este plugin seguir la estructura de nuestra descripcin.<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p>El plugin root tendr un mtodo que retorna una Bitcoin Wallet a partir de un Id.</p>
</li>
<li>
<p>La bitcoin wallet tendr un mtodo que retorne las transacciones, este tendr dos parmetros, el
offset y la cantidad mxima de transacciones que se desean traer. Adems deber tener un mtodo que
retorne un objeto que permita hacer el dbito, crdito y consulta de balance del Book Balance y otro
mtodo que retorne un objeto con igual interfaz pero que realice las operaciones sobre el Available
Balance.<br></p>
</li>
<li>
<p>Los objetos que manipulan el Available y Book Balance actuarn sobre un objeto intermedio que ser
quin administre las tablas de la base de datos.<br></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_events">Events</h6>
<div class="paragraph">
<p>Al actualizar satisfactoriamente los balances debemos informar al sistema que hubo una actualizacin
de los mismos, para ello dispararemos dos eventos.<br></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">BitcoinWalletAvailableBalanceChangedEvent</dt>
<dd>
<p>Este evebto debe lanzarse cuando el Available Balance es
alterado tras una operacin de crdito o dbito.</p>
<div class="dlist">
<dl>
<dt class="hdlist1">BitcoinWalletBookBalanceChangedEvent</dt>
<dd>
<p>Este evento debe lanzarse cuando el Book Balance es alterado
tras una operacin de crdito o dbito.</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="_implementation_details">Implementation Details</h6>
<div class="paragraph">
<p>Cuando llega una transaccin a aplicar debemos registrar la misma en la tabla de transacciones.<br>
Para completar los campos de la tabla debemos calcular el Running Book Balance y el Available Book
Balance, lo cual involucra:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Consultar el balance actual.</p>
</li>
<li>
<p>Dependiendo si es un crdito en el Book o Available Balance, sumar al campo del Running Balance
correspondiente el monto de la transaccin.</p>
</li>
<li>
<p>Actualizar el balance actual.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Esto trae un problema que ilustraremos con el siguiente ejemplo:</p>
</div>
<div class="paragraph">
<p>Supongamos que el balance actual del es 2 BTC de Book Balance y tambin 2 BTC del Available Balance.
Usermos la notacin de pares ordenados (Book Balance, Available Balance) para simplificar la notacin.
Es decir, que tenemos un balance (2,2).<br>
Supongamos que un thread pide hacer un crdito de 1 BTC al Book Balance. Lo intuitivo es que el thread que
ejecute el primer crdito registrar una transaccin con Running Book Balance de 3 BTC y balance (3,2), mientras
que el segundo thread dejar un Running Book Balance de 4 BTC y un balance de (4,2). Sin embargo, podra
darse la siguiente secuencia:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El primer thread llama al credit. Lee que el balance es (2,2)</p>
</li>
<li>
<p>Antes de que el primer thread complete su operacin de actualizar el balance, el segundo thread llama
al mtodo de credit y tambin lee un balance de (2,2).</p>
</li>
<li>
<p>El primer thread actualiza las tablas y coloca que su Running Book Balance es de (3,2), es decir,
el balance que ley ms 1 BTC que era el monto de la transaccin.</p>
</li>
<li>
<p>El segundo thread tambin actualiza las tablas y como ley un balance (2,2) tambin coloca una transaccin
con Running Book Balance de 3 BTC y balance (3,2)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Como vemos se pierde una transaccin en los balances.<br>
Vamos a necesitar que se puedan realizar estas actualizaciones de manera transaccional por lo que
debemos realizar cambios al plugin de base de datos. Posiblemente lo ms adecuado sea poder hacer una
lectura dentro de una transaccin as como se realizan updates e inserciones.<br></p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Fermat-DMP-CryptoTransactionLayer">Crypto Transaction Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="Fermat-DMP-CryptoTransactionLayer-LayerDescription">Layer Description</h3>
<div class="paragraph">
<p>Transactions are one of the core functionalities developed over Fermat.<br>
Fermat uses crypto currencies to transfer the real value from a user to another, but we have to remember that you can make transactions of other assets apart from crypto currencies.<br>
For example, we can transfer 100 dollars from one wallet to another. The mechanism to do this involve the value transaction which is managed by transferring an amount of crypto currency like bitcoin equivalent to 100 dollars between the users and an information transaction which provide the information about the meaning of those bitcoins. In this case the information would be that the bitcoins sent by the crypto network are represented as 100 dollars.<br></p>
</div>
<div class="paragraph">
<p>Therefore, when we make a transaction in Fermat we can identify two components: <strong>meta data</strong> and <strong>value</strong>.<br>
The value at this moment is stored at a crypto vault, specifically under a crypto addresses managed managed by the vault plugin. On the other hand the information tell us, among other things, which and how much fiat currency or other asset is beign transmitted.<br></p>
</div>
<div class="paragraph">
<p>The meta data and the value travel through different channels, so they will be be acknowledged by a device at different moments in time. This means that we can receive a notification that 100 dollars have been sent to us before we get any new bitcoins that represent the value or vice versa, we can get new bitcoins before receiving the notification of what those bitcoins represent and why they have been sent.<br></p>
</div>
<div class="paragraph">
<p>The responsibility of this layer is to keep these concepts synchronized and within each device the transactional and balance information in a consistent state. The plug-ins that live here detect the arrival of value and information and will update the balances of the system vaults and wallets in an atomic transactional way, i.e. they will update things only when both meta data <strong>and</strong> value are acknowledged.<br>
No loss of value nor meta data can be permitted. The mechanisms implemented by this layer will need to contemplate many different kinds of problems (device shut down, network failure, etc.).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The plug-ins in this layer will need to communicate with the wallets and crypto vaults using events or at least a more complex mechanism that simple method call. The plug-ins need to know that the information inside the wallets and volt was actually updated and persisted before ending the synchronization protocol.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the next section we will explore a general idea behind the protocols and failures considered in the design of this layer.</p>
</div>
</div>
<div class="sect2">
<h3 id="_transaction_data_structure">Transaction Data Structure</h3>
<div class="paragraph">
<p>To attack the problems we deal with in this layer we will need to design a few data structures to contain and share important information.<br>
To simplify the analysis let&#8217;s give a name to the data strcutures that contains the value and information associated to the fermat transaction. We will call them TransactionInformation and MetaTransactionInformation respectively.<br></p>
</div>
<div class="paragraph">
<p>As we will get the value and meta-value separetely and in no predictable order we will introduce in the MetaTransactionInformation a reference to the associated TransactionInformation. In this way we will be able to know when we have all the information needed to reflect the transaction in the wallets among other components.<br></p>
</div>
<div class="paragraph">
<p>The TransactionInformation will store.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The crypto currency we are dealing with as value.</p>
</li>
<li>
<p>The amount of crypto currency.</p>
</li>
<li>
<p>A transaction identifier that distinguish the crypto transaction.</p>
</li>
<li>
<p>The source crypto address of the transaction.</p>
</li>
<li>
<p>The destination crypto address of the transaction.</p>
</li>
<li>
<p>The timestamp that stablish the creation time of the transaction.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
In a single crypto transaction could be bundled many meta transactions. (Think for the future)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The MetaTransactionInformation will store:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The asset represented by the transaction (fiat currency, bonds, etc)</p>
</li>
<li>
<p>A representation of relevant information associated to the asset, e.g. in fiat currency would be the amount of currency involved.</p>
</li>
<li>
<p>The transaction identifier of the associated TransactionInformation.</p>
</li>
<li>
<p>The timestamp that stablish the creation time of the transaction.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
We could consider as a simple secutiry mechanism to ask for this timestamp to be the same timestamp present in the associated TransactionInformation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This cointainers descriptions are a draft presentation. We will add some fields to them to attack the syncronization problems.<br></p>
</div>
<div class="paragraph">
<p>An important aspect to consider is that lower layers (like network services and crypto networks) will interact with this containers as they are the layers that will give us this information.<br></p>
</div>
</div>
<div class="sect2">
<h3 id="Fermat-DMP-CryptoTransactionLayer-TransactionTransferProtocol">Transaction Transference Protocols</h3>

</div>
<div class="sect2">
<h3 id="_transaction_transference_protocol_version_1">Transaction Transference Protocol - Version 1</h3>
<div class="paragraph">
<p>Date: May 6th 2015<br>
Author: Ezequiel Postan &lt;<a href="mailto:ezequiel_postan@hotmail.com">ezequiel_postan@hotmail.com</a>&gt;</p>
</div>
<div class="paragraph">
<p>Este protocolo involucra dos tipos de mdulos T y R. Los tipo T transfieren la responsabilidad de transacciones que poseen y los tipo R reciben la responsabilidad de las transacciones. El tener la responsabilidad significa que deben realizar alguna tarea con la informacin de la transaccin transmitida.<br></p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Este protocolo asume que los mdulos tipo R saben quienes son sus T asociados (quienes les transmiten transacciones). Los mdulos tipo T no conocen la ideantidad de los R, sin embargo es posible que un mdulo de tipo T deba clasificar transacciones y entregar distintos grupos a distintos receptores o dar la opcin de dar distintos gruposa un mismo receptor. Presentaremos primero el caso de un slo emisor y receptor y luego agregaremos leves adaptaciones para adaptarnos al caso ms general.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sean T un mdulo de tipo T y R un mdulo de tipo R.
Debemos considerar algunas cosas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>T puede realizar otras acciones previas a inicar el traspaso de la transacin.</p>
</li>
<li>
<p>R puede realizar alguna tarea tras recibir la transaccin.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Para tener esto en cuanta en los pasos del protocolo, a cada transaccin se le agregar un estado de la transaccin y un estado de notificacin, que notaremos como un par (ESTADO_DE_TRANSACCIN, ESTADO_DE_NOTIFICACIN).<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p>El estado de la transaccin podr ser: ACKNOWLEDGED, RESPONSIBLE, DELIVERED o APPLIED.</p>
</li>
<li>
<p>El estado de la notificacin ser NO_ACTION_REQUIRED, TO_BE_NOTIFIED, RECEPTION_NOTIFIED o SENDING_NOTIFIED.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El significado y uso de cada estado se explicar a continuacin junto con el protocolo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Cuando digamos que T recibe/registra una transaccin nueva, nos referimos a que tiene una nueva transaccin que procesar.
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<div class="title">Pasos del protocolo</div>
<ol class="arabic">
<li>
<p>T registra una transaccin nueva que debe procesar, entonces la guarda en su base de datos interna con el par de estados (RESPONSIBLE, NO_ACTION_REQUIRED).</p>
</li>
<li>
<p>Cuando T (siguiendo su lgica interna) concluye que debe enviar transacciones que estn en el estado (RESPONSIBLE,NO_ACTION_REQUIRED) a otro mdulo (que ser de tipo R), pasa a estas transacciones al estado   (RESPONSIBLE, TO_BE_NOTIFIED).</p>
</li>
<li>
<p>Peridicamente T revisa si tiene transacciones en la combinacin (RESPONSIBLE,TO_BE_NOTIFIED) o (RESPONSIBLE, SENDING_NOTIFIED).</p>
<div class="ulist">
<ul>
<li>
<p>Si tiene transacciones en alguno de esos pares de estados, enva el evento TransactionsWaitingTransferenceEvent, para que un mdulo responsable se haga cargo y <strong>luego de envar el evento</strong> pasa las transacciones del estado (RESPONSIBLE,TO_BE_NOTIFIED) al estado (RESPONSIBLE, SENDING_NOTIFIED), las que ya estaban en SENDING_NOTIFIED no cambian su estado.</p>
</li>
<li>
<p>Si no tiene transacciones en ese estado sigue con el anlisis del resto de las transacciones.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Por otro lado, cuando R escucha el evento que lanz T, mira que el origen del evento es T y llama a un mtodo de la interfaz de T que retorna una lista con todas las transacciones que tiene guardadas en estado (RESPONSIBLE, SENDING_NOTIFIED). <strong>T no cambia el estado de las transacciones que tiene almacenadas cuando R hace esta consulta.</strong></p>
</li>
<li>
<p>R recorre la lista y almacena en una base de datos interna cada transaccin de a una a la vez con el estado (ACKNOWLEDGED, TO_BE_NOTIFIED).</p>
</li>
<li>
<p>Luego, para cada transaccin en estado (ACKNOWLEDGED, TO_BE_NOTIFIED) en su base de datos, R llama a otro mtodo de T al cual le pasa el ID de la transaccin. La ejecucin de este mtodo marca en la base de datos <strong>de T</strong> a dicha transaccin como (DELIVERED, RECEPTION_NOTIFIED). <strong>Luego de esa llamada al mtodo de T</strong>, <strong>R</strong> marca la transaccin en estado (RESPONSIBLE, RECEPTION_NOTIFIED).</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
El motivo por el cual primero se notifica y luego se confirma se hace para garantizar que la transaccin fue correctamente confirmada por T antes de marcar que lo fue en la base de datos de R.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Aqu termina el protocolo de traspaso simple, pero podemos considerar un paso extra para contemplar la accin que realiza R sobre las transacciones recibidas.</p>
</div>
<div class="olist arabic">
<ol class="arabic" start="7">
<li>
<p>R toma las transacciones en estado (RESPONSIBLE, RECEPTION_NOTIFIED) y realiza su tarea. <strong>Luego de aplcar la tarea</strong> las pasa a (APPLIED, RECEPTION_NOTIFIED)</p>
</li>
</ol>
</div>
<div id="Fermat-DMP-CryptoTransactionLayer-TransactionTransferProtocol-TransactionSenderAprox" class="ulist">
<div class="title">NOTAS DEL PROTOCOLO</div>
<ul>
<li>
<p>Dado que mencionamos dos mtodos de T, podemos definir una interfaz llamada <code>TransactionsSender</code> que los identifique.</p>
<div class="ulist">
<ul>
<li>
<p><code>List&lt;TransactionInformation&gt; getPendingTransactions()</code> para obtener la lista de transacciones a traspazar</p>
</li>
<li>
<p><code>void confirmReception(TransactionID x)</code> para comunicar la recepcin de una transaccin.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Para la versin final del protocolo esta interfaz se modificar levemente.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando se involucra slo a dos mdulos (uno de tipo R y otro T), este protocolo se implementa con tres agentes en T y otros tres en R.</p>
<div class="ulist">
<ul>
<li>
<p>El main thread de T es quien implementa la interfaz de transacciones de T (los mtodos.</p>
</li>
<li>
<p>En primer agente de T es quien monitorea la aparicin de nuevas transacciones y las escribe en una tabla con el estado (RESPONSIBLE, NO_ACTION_INTENDED).</p>
</li>
<li>
<p>El segundo agente mira esa tabla, ejecuta una lgica interna y cuando determina que deben traspasarse las transacciones a otro mdulo pasa las transacciones correspondientes del estado (RESPONSIBLE, NO_ACTION_INTENDED) a (RESPONSIBLE, TO_BE_NOTIFIED).</p>
</li>
<li>
<p>El tercer agente es quien se despierta peridicamente, y cuando encuentra transacciones en estado (RESPONSIBLE, TO_BE_NOTIFIED) o (RESPONSIBLE, SENDING_NOTIFIED) enva el evento TransactionsWaitingTransferenceEvent y marca las que eran TO_BE_NOTIFIED como (RESPONSIBLE, SENDING_NOTIFIED). <strong>Notar que sigue en estado RESPONSIBLE</strong>.</p>
</li>
<li>
<p>El main thread de R es quien recibe los eventos de T y los registra en una base de datos interna.</p>
</li>
<li>
<p>El primer agente lee los eventos de esta base de datos que llena el main thread, va a buscar la lista de transacciones a T y las guarda una por una en otra tabla de la base de datos con el estado (ACKNOWLEDGED, TO_BE_NOTIFIED).</p>
</li>
<li>
<p>El segundo agente mira la tabla que llena el agente anterior con transacciones nuevas y le informa a T que recibi correctamente las transacciones de a una a la vez (a travs del mtodo <code>confirmReception</code>). Entonces, <strong>tras confirmarle a T la recepcin</strong> pasa la misma al estado (RESPONSIBLE, NOTIFIED).</p>
</li>
<li>
<p>El tercer agente aplica la tarea de R sobre las transacciones (RESPONSIBLE, NOTIFIED) y las pasa al estado (APPLIED, NO_ACTION_REQUIRED).</p>
</li>
</ul>
</div>
</li>
<li>
<p>Si nos paramos en una sola tranaccin vemos este ciclo de estados en las tablas de T y R.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>
            T         R
   1      (R,NAR)
   2      (R,TBN)
   3      (R,SN)
   4                (AC,TBN)
   5      (D,RN)
   6                (R,RN)
   7                (AP,RN)

   Referencias:
   R: RESPONSIBLE        NAR: NO_ACTION_REQUIRED
   D: DELIVERED          TBN: TO_BE_NOTIFIED
   AC: ACKNOWLEDGE       SN: SENDING_NOTIFIED
   AP: APPLIED           RN: RECEPTION_NOTIFIED</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#Fermat-DMP-CryptoTransactionLayer-TransactionTransferProtocol-SBDProtocol">Ms adelante</a> hablaremos del caso de una comunicacin que involucra tres mdulos, uno de tipo T (emisor original), uno de tipo R (receptor final) y un mdulo intermedio que acta como tipo R para el emisor original y como tipo T para el receptor final (un puente).</p>
</li>
<li>
<p>Al iniciarse un mdulo de tipo R, deber consultar si sus mdulos T asociados tienen transacciones acumuladas. Esto se debe a que el mdulo pudo inicializarse tras haber perdido varias notificaciones de transacciones nuevas.</p>
</li>
<li>
<p>Claramente puede llegar una nueva transaccin a T antes que R procese toda la lista de transacciones que ha recibido en una consulta anterior. En este caso T podra disparar nuevamente el evento de que avisa que tiene nuevas transacciones.<br>
El primer thread de R recibir ese evento, y luego el segundo thread probablemente traer, en la lista de transacciones nueva, transacciones que ya ha registrado pero an el tercer thread no ha confirmado recepcin.<br>
Esto da lugar a que se intente guardar en la base de datos una transaccin ya almacenada, dicho caso no deber considerarse como un error y simplemente deber ser ignorado.<br></p>
</li>
<li>
<p>Por otro lado T debe estar preparado para el aviso de que se desea notificar que una transaccin se proces ms de una vez. Esto puede darse en el caso en que el tercer thread de R notific la recepcin pero no lleg a persistir en su base de datos el cambio de estado a NOTIFIED, T ignorar el aviso y si todo es correcto esta vez R s podr marcar la transaccin como NOTIFIED.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="Fermat-DMP-CryptoTransactionLayer-TransactionTransferProtocol-SBDProtocol">Caso de tres mdulos</h4>
<div class="paragraph">
<p>Llamaremos a este caso el Protocolo SBD (Protocolo <strong>S</strong>ource-<strong>B</strong>ridge-<strong>D</strong>estination).<br>
En este caso tenemos tres mdulos involucrados en el intercambio de transacciones.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un mdulo S de tipo T (emisor original).</p>
</li>
<li>
<p>Un mdulo D de tipo R (destinatario final)</p>
</li>
<li>
<p>Un mdulo B que es tanto de tipo T como R (puente entre E y R)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La utilidad de este protocolo se da cuando un mdulo (S) debe delegar una transaccin pero no tiene forma de saber a quin debe hacerlo. En este caso se coloca a un receptor temporal (B) que s puede determinar quin es el receptor indicado para la transaccin (D).<br></p>
</div>
<div class="paragraph">
<p>Las variaciones a incorporar leves. Los mdulos S y D actuarn como explicamos antes en el protocolo simple (no saben que hay un puente), el puente "simplemente" har que su tercer agente (correspondiente al tipo R, o sea el de aplicacin) lea la tabla que llena el agente 2 y acta como un mdulo tipo T cuya accin es envar las transacciones cuando estn en estado (RESPONSIBLE, NOTIFIED) en lugar de (RESPONSABLE, TO_BE_NOTIFIED)).<br>
Al esperar que estn en NOTIFIED en lugar de TO_BE_NOTIFIED se garantiza que el traspazo de la transaccin de S a B fue completado exitosamente antes de comenzar a transmitir de B a D.</p>
</div>
<div class="paragraph">
<p>Para considerar la distincin de receptores y otros criterios de clasificacin, agregaremos dos parmetros al mtodo <code>getPendingTransactions</code> de la interfaz <a href="#Fermat-DMP-CryptoTransactionLayer-TransactionTransferProtocol-TransactionSenderAprox">TransactionSender</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>  List&lt;TransactionInformation&gt; getPendingTransactions(ReceptorType receptorType, TransactionDescription description)</code></pre>
</div>
</div>
<div class="paragraph">
<p>donde <code>receptorType</code> indicar el tipo de receptor al que se le puede entregar la transaccin y <code>descriprion</code> ser la descripcin del tipo de transacciones que debe usarse. Ambos sern enums que encapsulan un string.</p>
</div>
<div class="paragraph">
<p>Revisemos los pasos, el pasaje de las transacciones de S a B es el protocolo normal para mandar de un T a un R.<br>
As que tenemos que B tiene transacciones despus del paso 5 del protocolo. Es decir, con el estado (RESPONSIBLE, RECEPTION_NOTIFIED).<br>
Aqu el paso 7 ser que el tercer agente de B decide a quin debe enviar algunas transacciones, las pasa al estado (RESPONSIBLE, TO_BE_NOTIFIED)  (combinacin de estados que no se da en el protocolo simple) y marca la transaccin con el receptorType adecuado. Tambin anota el evento a lanzar segn el anlisis realizado.
Un cuarto agente controlar peridicamente si hay transacciones en este estado (RESPONSIBLE, TO_BE_NOTIFIED), lanzar el evento que indic el thread anterior y pasar la transaccin a (RESPONSIBLE, SENDING_NOTIFIED).<br>
La implementacin del mtodo <code>confirmReception</code> de B pasar las transacciones de (RESPONSIBLE, SENDING_NOTIFIED) a
(DELIVERED, SENDING_NOTIFIED) cerrando la participacin de B.
Cuando D pida las transacciones colocar el receptorType que lo identifica y posiblemente una descripcin sobre la transacciones que quiere retirar (por ejemplo que estn en crypto estado identified) como parmetros de <code>getPendingTransaction</code></p>
</div>
<div class="paragraph">
<p>Nuevamente, si nos paramos en una sola tranaccin vemos este ciclo de estados en las tablas de T y R.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>
              S         B         D
    1      (R,NAR)
    2      (R,TBN)
    3      (R,SN)
    4               (AC,TBN)
    5      (D,RN)
    6                (R,RN)
    7                (R,TBN)
    8                (R,SN)
    9                          (AC,TBN)
   10                (D,RN)
   11                           (R,RN)
   12                          (AP,RN)

   Referencias:
   R: RESPONSIBLE        NAR: NO_ACTION_REQUIRED
   D: DELIVERED          TBN: TO_BE_NOTIFIED
   AC: ACKNOWLEDGE       SN: SENDING_NOTIFIED
   AP: APPLIED           RN: RECEPTION_NOTIFIED</code></pre>
</div>
</div>
<div class="paragraph">
<p>Estos protocolos sern implementados por diversos plug-ins que interactan con esta capa.</p>
</div>
</div>
<div class="sect3">
<h4 id="_problemas_a_resolver">Problemas a resolver</h4>
<div class="sect4">
<h5 id="_analizar_livelocks">Analizar livelocks</h5>
<div class="paragraph">
<p>Ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El tercer agente de T encuentra transacciones en estado (RESPONSIBLE, TO_BE_NOTIFIED) y enva el evento TransactionsWaitingTransferenceEvent. Antes de que actualice la transaccin al estado (RESPONSIBLE, SENDING_NOTIFIED) el agente de R se lleva la transaccin, la registra y confirma su recepcin. Esto lleva a que el estado cambie a (DELIVERED,RECEPTION_CONFIRMED). Finalmente este agente ejecuta la actualizacin en su thread y escribe el estado de notificacin SENDING_NOTIFIED.
Aqu dependemos de la implementacin que se haya hecho en el plug-in de databaseManager:</p>
<div class="ulist">
<ul>
<li>
<p>Si se actualizan todos los campos tendremos el estado final (RESPONSIBLE, SENDING_NOTIFIED) y la transaccin pasar a ser enviada de nuevo. Para resolver eso deberamos hacer que los mdulos R al recibir varias veces una transaccin, no lancen un error pero s deben llamar de nuevo al mtodo de notificacin.</p>
</li>
<li>
<p>Si se actualiza slo el campo modificado del record se obtendra el estado final (DELIVERED,SENDING_NOTIFIED), lo cual no es del todo un problema pero demuestra que algo simple como esto parece tiene muchos detalles acarreados por la concurrencia.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_no_aplicable">No aplicable</h5>
<div class="paragraph">
<p>Si bien este es un buen inicio, no soluciona el problema. En la versin 2 refinamos las cosas para que se pueda adaptar mejor a cambios.</p>
</div>
</div>
<div class="sect4">
<h5 id="_simplicidad">Simplicidad</h5>
<div class="paragraph">
<p>ESTO DE ABAJO EST MAL, PORQUE SE MARCA COMO (ACKNOWLEDGE,TO_BE_NOTIFIED) y no como RESPONSIBLE.
Tengo la impresin de que esto anda y que la explicacin es entendible y ser fcil de entender la implementacin tras leer esto. La duda que tengo es que es muy evidente que puedo fusionar algunos threads. Por ejemplo, podra optimizarse la implementacin si el agente 1 de R marca la transaccin primero como (RESPONSIBLE,TO_BE_NOTIFIED), luego llama a <code>confirrmReception</code> y finalmente cambia la transaccin al estado (RESPONSIBLE,RECEPTION_NOTIFIED). Esto permitira eliminar el agente 2 dado que de todas formas el protocolo est preparado para recibir varias veces la misma transaccin (si es que llega a darse que se cae el equipo antes de confirmar la transaccin o entre la confirmacin y la persistencia en la base de datos (de R) de la confirmacin).<br>
La optimizacin trae dos defectos leves:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Uno semntico es que temporalmente ambos mdulos (R y T) tendrn la misma transaccin con el estado RESPONSIBLE, en cuyo caso podramos asumir que ambos son responsables de esa transaccin (como dijimos antes, esto no tiene problemas de implementacin).</p>
</li>
<li>
<p>El segundo tiene relacin con el <a href="#Fermat-DMP-CryptoTransactionLayer-TransactionTransferProtocol-SBDProtocol">protocolo SBD</a>, el cual debera considear nuevos estados para las transacciones y estados de notificacin. Pero obviamente puede implementarse.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Habra que ver el anlisis fino, si vemos la seccin anterior se encuantran posibles trazas que podran generar problemas. Fusionar threads reduce la concurrencia pero les da ms tareas a un mismo thread por lo que las acciones que realiza pueden ser ms complejas de analizar.</p>
</div>
</div>
<div class="sect4">
<h5 id="_eventos_esto_se_va_a_mover_a_la_documentaci_n_del_plug_in_incoming_crypto">Eventos (ESTO SE VA A MOVER A LA DOCUMENTACIN DEL PLUG-IN INCOMING CRYPTO)</h5>
<div class="paragraph">
<p>Necesitamos hacer que el incoming crypto implemente un puente del protocolo SBP con un evento especial para avisarle a los incoming crypto especializados que le pidan transacciones nuevas.<br>
Por lo que veo hay que hacer que el mtodo <code>getPendingTransactions</code> tome un parmetro que diga qu destino tienen las transacciones. As quin recibi el evento se lleva las que les corresponde y no las de otros.</p>
</div>
<div class="paragraph">
<p>Para los estados de las crypto not que hay eventos especializados como</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IncomingCryptoIdentifiedFromIntraUserEvent</p>
</li>
<li>
<p>IncomingCryptoIdentifiedFromExtraUserEvent</p>
</li>
<li>
<p>&#8230;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por lo que probablemente habr usaremos dichos eventos.<br>
Hay que modificar las cosas para poder mandar y coordinar la comunicacin del crypto estado de cada transaccin (Identified, received, etc), esto lo veremos en la versin 2 y dejamos esto como gua/borrador de referencia.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_transaction_transference_protocol_version_2_draft">Transaction Transference Protocol - Version 2 (DRAFT)</h3>
<div class="paragraph">
<p>Date: Jun 6th 2015<br>
Author: Ezequiel Postan &lt;<a href="mailto:ezequiel_postan@hotmail.com">ezequiel_postan@hotmail.com</a>&gt;</p>
</div>
<div class="sect3">
<h4 id="_consideraciones">Consideraciones</h4>
<div class="ulist">
<ul>
<li>
<p>No se puede depender slo de los eventos informativos IncomingCryptoReceivedEvent e IncomingCryptoReversedEvent porque pueden detectarse transacciones crypto confirmadas sin que haya visto la primer confirmacin (porque estaba apagado el equipo por ejemplo). El protocolo de traspaso de transacciones slo depende de un evento que exige el traspaso de transacciones pendientes, usaresmo el evento IncomingCryptoTransactionsWaitingTransferenceEvent.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_problemas_de_la_versi_n_1">Problemas de la versin 1</h4>
<div class="ulist">
<ul>
<li>
<p>No separaba los conceptos de transaccin de la red crypto y transaccin de la plataforma. Cosa que notaremos ms adelante.</p>
</li>
<li>
<p>No plantea cmo organizar las cosas para reutilizar el protocolo para comunicar MetaTransactionInformation provenientes de los network services.</p>
</li>
<li>
<p>Problema "menor", podra ser ms eficiente</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_definiciones_preliminares">Definiciones preliminares</h4>
<div class="dlist">
<dl>
<dt class="hdlist1">Agente</dt>
<dd>
<p>Thread que realiza un trabajo en paralelo.</p>
</dd>
<dt class="hdlist1">Transaccin crypto</dt>
<dd>
<p>Mecanismo por el cual una red de crypto currencies registra el traspaso de valor de un usuario a otro.</p>
</dd>
<dt class="hdlist1">Transaccin</dt>
<dd>
<p>Tarea de modificar los estados de las wallets y crypto volt de manera transaccional</p>
</dd>
<dt class="hdlist1">CryptoStatus</dt>
<dd>
<p>Enum que lista los posbles estados de una transaccin crypto. Estos son:</p>
<div class="ulist">
<ul>
<li>
<p>PENDING_SUBMIT: Cuando la transaccin se cre internamente, pero an no fue distribuida en la red de Bitcoin. Este estado es importante slo para las transacciones salientes.</p>
</li>
<li>
<p>ON_CRYPTO_NETWORK: Cuando se ve la transaccin crypto en la red pero sin ninguna confirmacin</p>
</li>
<li>
<p>ON_BLOCKCHAIN: Cuando la transaccin crypto obtiene la primer confirmacin.</p>
</li>
<li>
<p>IRREVERSIBLE: Cuando la tramsaccin crypto obtiene suficientes confrmaciones para considerar la transaccin irreversble.</p>
</li>
<li>
<p>REVERSED: Cuando se reverte la transaccin.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Specialist</dt>
<dd>
<p>Enum que lista qu tipo de plug-in debe tomar posecin de la transaccin a traspazar. Este enum es necesario dado que este plug-in debe dar distintas transacciones a distintos plug-ins, por ende cuando un plug-in venga a tomar posesin de una transaccin debe indicar qu tipo de transacciones maneja.</p>
</dd>
<dt class="hdlist1">CryptoTransaction</dt>
<dd>
<p>Contenedor de datos con la informacin de una transaccin. Esta informacin es:</p>
<div class="ulist">
<ul>
<li>
<p>Hash de la transaccin</p>
</li>
<li>
<p>Direccin de Origen</p>
</li>
<li>
<p>Direccin de Destino</p>
</li>
<li>
<p>Crypto Currency</p>
</li>
<li>
<p>CryptoState</p>
</li>
<li>
<p>Monto</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Transaction</dt>
<dd>
<p>Contenedor de datos con la informacin de una transaccin. Estos datos son:</p>
<div class="ulist">
<ul>
<li>
<p>Un identificador distintivo (TransactionId)</p>
</li>
<li>
<p>Un elemento de tipo CryptoTransaction</p>
</li>
<li>
<p>Un valor de Specialist (los receptores de transacciones crypto pueden colocar en este campo el valor CRYPTO_ROUTER para mencionar al incomingcrypto)</p>
</li>
<li>
<p>Un timestamp que coloca quien genera la transaccn. (En este caso la red bitcoin)</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">TransactionStatus</dt>
<dd>
<p>Estado interno que guarda un plug-in sobre cadaa transaccin que describe su relacin con la misma. El estado puede ser:</p>
<div class="ulist">
<ul>
<li>
<p>ACKNOWLEDGE: Cuando recibe una transaccin pero an no confirm su recepcin.</p>
</li>
<li>
<p>RESPONSIBLE: Cuando posee la transaccin y an no la aplic ni la traspas</p>
</li>
<li>
<p>DELIVERED: Cuando traspas la transaccin a otro plug-in para que este se haga responsable.</p>
</li>
<li>
<p>APPLIED: Cuando aplic la transaccin</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">ProtocolStatus</dt>
<dd>
<p>Estado interno que guarda un plug-in sobre cada transaccin que describe su situacin de traspaso de la misma. Este estado puede ser:</p>
<div class="ulist">
<ul>
<li>
<p>NO_ACTION_REQUIRED: Cuando se tiene una transaccin pero no se requiere ejecutar ningn traspaso o aplicacin an.</p>
</li>
<li>
<p>TO_BE_NOTIFIED: Cuando se debe notificar un evento para iniciar el traspaso de una transaccin.</p>
</li>
<li>
<p>SENDING_NOTIFIED: Cuando se emiti el evento que notifica el pedido de traspaso de la transaccin.</p>
</li>
<li>
<p>RECEPTION_NOTIFIED: Cuando se recibe la confirmacin de receptin del traspaso de una transaccin.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">TransactionSender</dt>
<dd>
<p>Interfaz que implementan los plug-ins que traspasan transacciones a otros mdulos, brinda los siguientes mtodos:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>  void confirmReception(TransactionId transactionId)
  List&lt;Transaction&gt; getPendingTransactions(Specialist specialist)</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>El mtodo confirmedReception marca la transaccin marcada como argumento como (DELIVERED,RECEPTION_NOTIFIED).
El mtodo getPendingTransactions retorna la lista de todas las transacciones con ProtocolStatus SENDING_NOTIFIED que tienen como Specialist al pasado como argumento. Notar que no camba el estado de ninguna transaccin.</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Respetar que <code>getPendingTransactions</code> retorne slo lo que est en estado (RESPONSIBLE,SENDING_NOTIFIED). No intentar "optimizar" pasando las transacciones en TO_BE_NOTIFIED porque traera graves problemas de concurrencia.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Por cuestiones de concurrencia y reutilizacin de cdigo la interfaz cambiar levemente en la implementacin, ver <a href="#Transaction-Transference-Protocol-v2-ImplementationNotes">notas de implementacin</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_convensiones">Convensiones</h4>
<div class="ulist">
<ul>
<li>
<p>Escribiremos que una transaccin tiene un estado (TS,PS) para describir que su TransactionStatus
es TS y el ProtocolStatus es PS.</p>
</li>
<li>
<p>Dada una transaccin crypto, una transaccin asociada es una transaccin que tiene como
CryptoTransaction un contenedor con los datos de la transaccin crypto. Notar que una misma
transaccin crypto puede tener ms de una transaccin asociada. Esto se da por ejemplo cuando,
al detectar que una transaccin es confirmada por primera vez se genera un objeto Transaction, y si
esta transaccin crypto se reversa generar un nuevo objeto transaction. La duferencia entre ambos
objetos ser primero el identificador de la transaccin y por otro lado la transaccin crypto que
contiene el objeto tendr un crypto estado distinto.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_protocolo">Protocolo</h4>
<div class="paragraph">
<p>Para simplificar la explicacin supondemos que el receptor de las transacciones crypto y por ende el emisor original de las transacciones es el plug-in de la red bitcoin. A su vez, usaremos el trmino <em>red bitcoin</em> para referirnos a este plug-in. El plug-in al que traspasa las transacciones la red btcoin ser el IncomingCrypto y el plug-in que aplicalas transacciones el el IncomingCryptoExtraUser.</p>
</div>
<div class="paragraph">
<p>Analicemos los pasos del protocolo de traspaso de transacciones en estos componentes.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Cuando la red bitcoin despierta, revisa las transacciones <strong>nuevas</strong> que han llegado por la red. Al analizar el crypto estado de cada transaccin crypto se tendr varias opciones:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Si el crypto estado es ON_CRYPTO_NETWORK, almacena una transaccin asociada con estado (APPLY,RESPONSIBLE,TO_BE_NOTIFIED)</p>
</li>
<li>
<p>Si el crypto estado es ON_BLOCKCHAIN, almacena una transaccin asociada con estado (APPLY,RESPONSIBLE,TO_BE_NOTIFIED)</p>
</li>
<li>
<p>Si el crypto estado es REVERSED, almacena una transaccin asociada con estado (REVERT,RESPONSIBLE,TO_BE_NOTIFIED). <a href="#Transaction-Transference-Protocol-v2-Note1">VER NOTA</a></p>
</li>
</ol>
</div>
</li>
<li>
<p>Un agente de la red bitcoin detecta que hay transacciones crypto con ProtocolStatus TO_BE_NOTIFIED o SENDING_NOTIFIED, entonces enva el evento IncomingCryptoTransactionsWaitingTransferenceEvent.
Luego de lanzar el evento marca las transacciones que tena en TO_BE_NOTIFIED como SENDING_NOTIFIED. <a href="#Transaction-Transference-Protocol-v2-Note2">VER NOTA</a></p>
</li>
<li>
<p>El IncomngCrypto regstra el evento.</p>
</li>
<li>
<p>El MonitorAgent (un agente) del IncomingCrypto ve que hay transacciones pendientes y llama al mtodo <code>getPendingTransactions(CRYPTO_ROUTER)</code> de la fuente que emiti el evento, luego recorre la lista que devuelve y <strong>primero guarda en su base de datos</strong> a todas las transacciones colocndoles el estado (ACKNOWLEDGE,TO_BE_NOTIFIED). <strong>Luego</strong>, por cada transaccin en la base de datos con estado (ACKNOWLEDGE,TO_BE_NOTIFIED) (que pueden ser ms que las que guard recin) ejecuta los siguientes pasos <strong>en ese orden</strong>:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Llama al mtodo <code>confirmReception</code> con el TransactionId de la transaccin como parmetro.</p>
</li>
<li>
<p>Marca la transaccin como (RESPONSIBLE,NO_ACTION_REQUIRED).</p>
</li>
</ol>
</div>
</li>
<li>
<p>El RelayAgent (un segundo agente) del IncomingCrypto analizar las transacciones con estado (RESPONSIBLE,NO_ACTION_REQUIRED). Por cada una de ellas hara los siguientes pasos <strong>en el orden enunciado</strong></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Deducira a partir de la informacin de las mismas su Specialist y lo marcara.</p>
</li>
<li>
<p>Pasara la transaccin al estado (RESPONSIBLE,TO_BE_NOTIFIED)</p>
</li>
<li>
<p>Cuando termina de recorrer la lista recorre ahora todas las que estn con TransactonStatus RESPONSIBLE y ProtocolStatus TO_BE_NOTIFIED o SENDING_NOTIFIED. Registra todos los especialistas que vio en <strong>este recoorido</strong> (no intentar optimizar usando el recorrido anterior porque puede perderse si el sistema se cae) y realiza los siguente pasos <strong>en el orden enunciado</strong>:</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Por cada Specialist registrado en el recorrido anterior lanza el evento correspondiente (IncomingCryptTransactionsWaitingTransference<em><strong>Specalist</strong></em>Event)</p>
</li>
<li>
<p>Pasa cada transaccin con ProtocolStatus TO_BE_NOTIFIED a SENDING_NOTIFED. <a href="#Transaction-Transference-Protocol-v2-Note3">VER NOTA</a></p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>EL incomng crypto extra-user escuchar el evento.</p>
</li>
<li>
<p>El MonitorAgent (un agente) del IncomingCryptoExtraUser ve que hay transacciones pendientes y llama al mtodo <code>getPendingTransactions(EXTRA_USER)</code> del IncomingCrypto, luego recorre la lista que devuelve y <strong>primero guarda en su base de datos</strong> a todas las transacciones asignndoles el estado (ACKNOWLEDGE,TO_BE_NOTIFIED). <strong>Luego</strong>, por cada transaccin en la base de datos con estad (ACKNOWLEDGE,TO_BE_NOTIFIED) (que pueden ser ms que las que guard recin) ejecuta los siguientes pasos <strong>en ese orden</strong>:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Llama al mtodo <code>confirmReception</code> con el TransactionId de la transaccin como parmetro, con lo que el IncomingCrypto marcar la transaccin que se indique como (DELIVIRED,RECEPTION_NOTIFIED) en la base de datos del IncomingCrypto.</p>
</li>
<li>
<p>Marca la transaccin como (RESPONSIBLE,NO_ACTION_REQUIRED).</p>
</li>
</ol>
</div>
</li>
<li>
<p>El RelayAgente (segundo agente) del IncomingCryptoExtraUser ve las transacciones que tiene y decide si debe ejecutarlas o no, <strong>luego de ejecutar la transaccin</strong> la marca como (APPLIED,NO_ACTION_REQUIRED)</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_consideraciones_2">Consideraciones</h4>
<div class="paragraph">
<p>El protocolo debe estar preparado para la cada del dispostvo en cualquier paso, por ende las siguientes implementaciones son necesarias.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si un emisor enva el vento para que retiren transacciones y el receptor las retira, almacena, pero el sistema cae antes que pueda confirmarl su receptin termnaremos con este estado:</p>
<div class="ulist">
<ul>
<li>
<p>El receptor tendr transacciones en su base de datos en (ACKNOWLEDGED,TO_BE_NOTIFIED)</p>
</li>
<li>
<p>El emisor no sabr que el receptor ya las retir. Recordar que el receptor slo retra lo que est en (RESPONSIBLE,SENDING_NOTIFIED).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por ende cuando se levante el sistema, el receptor volver a pedir transacciones pendientes y recibir en la lista transacciones que ya tiene. Cuando esto ocurra, el receptor simplemente ignorar la excepcin que lanzar la base de datos por querer introducir algo que ya tenemos y proceder a confirmar la recepcin de la transaccin para que el emisor la saque de la prxima lista a mandar.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si un receptor llama al <code>confirmReception</code> y ants de pasar la transaccin de (ACKNOWLEDGED,TO_BE_NOTIFIED) a (RESPONSIBLE,NO_ACTION_REQUIRED) se cae el sistema tendremos la siguiente situacin:</p>
<div class="ulist">
<ul>
<li>
<p>El emisor tendr una transaccn confirmada como (DELIVERED,RECEPTION_NOTIFICED) que el receptor an tendr como (ACKNOWLEDGED,TO_BE_NOTIFIED). Por ende no se enviara en la siguiente lista de transacciones al llamar al mtodo <code>getPendingTransactions</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Es por esto que el agente que toma la lista de transacciones nuevas, tras registrarlas en su base de datos, vuelve a pedirle a la misma <strong>todas</strong> las transacciones en (ACKNOWLEDGED,TO_BE_NOTIFED). Ya que la que se haba confirmado pero no registrado confirmacin no estara en la lista obtenida de <code>getPendingTransactions</code>.
Lo que debemos considerar es entonces que cuando se llame al mtodo <code>confirmTransacton</code> ms de una vez con la misma transaccin, este no lance una excepcin sino que simplemente ignore la segunda confirmacin para que esta vez el receptor de la transaccin pueda pasarla al estado (RESPONSIBLE,NO_ACTION_REQUIRED)</p>
</div>
<div id="Transaction-Transference-Protocol-v2-Note1" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Quiero analizar la posibilidad de cancelar aqu mismo el envo del APPLY de la transaccin si an no se envi, pero es algo tarde cuando escribo esto, voy a verlo al levantarme con mi mente ms despierta. A diferencia de la <a href="#Transaction-Transference-Protocol-v2-Note3">ltma nota</a> aqu no es tan simple, porque el que notifica es otro thread.
</td>
</tr>
</table>
</div>
<div id="Transaction-Transference-Protocol-v2-Note2" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
DESPUS VI ESTO MS DESPEJADO Y ME DI CUENTA QUE ESTE PROBLEMA NO SE DA, PORQUE EL MRODO <code>getPrndeingTransactions</code> NO ENTREGARA TRANSACCIONES EN ESTADO TO_BE_NOTFIED, podra ignorarse esta nota, la dej para recordarlo yo.<br>
Esto visto en detalle muestra problemas de concurrencia nuevamente, ejemplo: lanzo el evento y el incoming crypto toma las transaccones, las confirma y cuando luego de confirmarlas es que recen este agente marca la transaccn al estado SENDING_NOTIFED, aqu dependo de cmo est implementado el mdulo de base de datos para saber si esto puede andar mal (no slo en si la base de datos usa un lock, sino tambien en cuanto a cmo actualiza un campo). Analizado sin mucho detalle creo que podra causar problemas al incorporar los reversed. Creo que con colocar un lock se podra solucionar.<br>
</td>
</tr>
</table>
</div>
<div id="Transaction-Transference-Protocol-v2-Note3" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Ac hay que analizar de nuevo la posibilidad de cancelar el envi de transacciones con accin APPLY si ya tengo registrado el REVERSED. Creo que en este caso puedo cancelar el traspaso si la transaccn tiene ProtocolStatus TO_BE_NOTIFIED.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_conclusiones_hasta_aqu">Conclusiones hasta aqu</h4>
<div class="ulist">
<ul>
<li>
<p>Las consideraciones de cambio que tengo presentes son:</p>
<div class="ulist">
<ul>
<li>
<p>Incorporacin de nuevos especalistas</p>
</li>
<li>
<p>Los criterios de decisin se podran encapsular en clases y usar el patrn de diseo strategy. Pero esto no llegu a verlo.</p>
</li>
<li>
<p>Consultas de informacn: Para que se consulte informacin, se podra tener uno o ms mtodos que simplemente no cambien ningn estado interno y retornen la informacin pedida.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Si parametrizamos el protocolo haciendo que la interfaz TransactionSender tenga un parmetro de tipo genrico podramos reutilizar el protocolo con otro tipo de transacciones, simplemente cambiaramos la clase CryptoTransaction por otro contenedor de datos que usaran el emisor y receptor.</p>
</li>
<li>
<p>Parece ser ms eficiente porque elimina un par de agentes.</p>
</li>
<li>
<p>Creo que los Network Services que transporten informacin de valor que deba sincronizarse usaran este protocolo con eventos especializados que indiquen nuevas meta-transacciones.</p>
</li>
<li>
<p>An hay que revisar esto y completar los pasos con el incoming-crypto-extra-user y ver si incorporar el incoming-crpyo-intra-user no rompe nada</p>
</li>
<li>
<p>Falta analizar el impacto del cambio de usar una transaccin crypto por cada meta transaccin a pasar a usar una UTXO por cada meta transaccin.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="Transaction-Transference-Protocol-v2-ImplementationNotes">Notas de implementacin (IncomingCrypto)</h4>
<div class="paragraph">
<p>Probablemente sea mejor leer primero <a href="#Transaction-Transference-Protocol-v2-NotaParaLuis">esta nota</a></p>
</div>
<div class="sect4">
<h5 id="_opci_n_1_propuesta_en_reuni_n_de_equipo_refinada_por_ezequiel_siguiendo_esa_idea">Opcin 1: Propuesta en reunin de equipo, refinada por Ezequiel siguiendo esa idea.</h5>
<div class="ulist">
<ul>
<li>
<p>El incoming crypto usar una clase (Registry) que compartirn los dos agentes de cada mdulo. Por cada mdulo el registry abrit una copia de la tabla que guarda las transacciones. Esto se hace para evitar problemas de concurrencia.</p>
</li>
<li>
<p>Tambin para solventar problemas de concurrencia, optamos por modificar la interfaz del pluginRoot. En lugar de implementar la interfaz <code>TransactionSender</code> definiremos una interfaz <code>IncomingCryptoManager</code> con el mtodo <code>TransactionSender getTransactionSender(Specialist specialist)</code>.<br>
La implementacin de esta interfaz har que retornemos una copia de la tabla de transacciones actual que lleva el manejador de la base de datos (haremos un open de la tabla para pasar una instancia de la abstraccin distinta, lo cual resuelve varias cuestiones de concurrencia).
Adems, notemos que podemos parametrizar las Transactions para que transporten otro tipo de datos fuera de transacciones crypto, esto ser de utilidad para reutilizar el cdigo. Por ltimo un nombre ms adecuado para la interfaz TransactionSender sera TransactionManager, las interfaces finales sern entonces:</p>
<div class="literalblock">
<div class="content">
<pre>public interface IncomingCryptoManager {
  TransactionManager&lt;CryptoTransaction&gt; getTransactionSender(Specialist specialist)
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>public interface TransactionManager&lt;E&gt; {
  public void confirmReception(UUID transactionId)
  public List&lt;Transaction&lt;E&gt;&gt; getPendingTransactions(Specialist specialist)
}</pre>
</div>
</div>
</li>
<li>
<p>Ser el mismo Registry quien implementar la interfaz <code>TransactionManager&lt;CryptoTransaction&gt;</code>.</p>
</li>
<li>
<p>Adems el Registry tendr los siguientes mtodos para los agentes:</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
EventWrapper es un contenedor de datos de informacin de eventos. Probablemente no hace falta.
</td>
</tr>
</table>
</div>
<div class="literalblock">
<div class="content">
<pre>// To manage events
// Used by the Monitor Agent
void saveNewEvent(String eventType, String eventSource) throws CantSaveEvent;
EventWrapper getNextPendingEvent() throws CantReadEvent;
void discardEvent(UUID eventId) throws CantReadEvent, CantSaveEvent;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>//To manage transactions</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>// User by the Monitor Agent
// Las coloca en (A,TBN)
void acknowledgeTransactions(List&lt;Transaction&lt;CryptoTransaction&gt;&gt; transactionList) CantAcknowledgeTransactionException;
// Retorna las que estn en (A,TBN)
List&lt;Transaction&lt;CryptoTransaction&gt;&gt; getAcknowledgedTransactions() CantGetTransactionsException;
// Pasa una de (R,NAR)
void acquireResponsibility(Transaction&lt;CryptoTransaction&gt; transaction) CantAcquireResponsibility;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>// Used by Relay Agent
// Retorna las (R,NAR)
List&lt;Transaction&lt;CryptoTransaction&gt;&gt; getResponsibleTransactions() CantAccessTransactionsException;
// Pasa la transaccin a TBN y le agrega el Specialist.
void setToNotify(UUID id, Specialist specialist)
// La lista de (R,TBN) o (R,SN)
List&lt;Transaction&lt;CryptoTransaction&gt;&gt; getResponsibleTransactionsPendingAction() CantAccessTransactionsException;
// Da los Specialist de las que estn en TBN y SN
List&lt;Specialist&gt; getSpecialists() CantReadSpecialistsException;
// Pasa las que son TBN a SN
void setSendingNotified() CantSaveTransactionsException;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_opci_2_contrapropuesta_de_ezequiel">Opci 2: Contrapropuesta de Ezequiel</h5>
<div class="ulist">
<ul>
<li>
<p>Tras analizar el tema de concurrencia llegu a la conclusin de que puedo evitar pasar el Registry a otros mdulos y adems puedo resolver los temas de concurrencia que hablamos hoy.</p>
</li>
<li>
<p>La solucin a los temas de concurrencia la hago abriendo la tabla que requiere usar cada mtodo del registry como primer sentencia del mtodo (cosa que igual tengo que hacer en la otra implementacin). Esto da un objeto Database propio a cada thread dado que las variables sern locales y esas son exclusivas por thread, por lo que la concurrencia pasa a ser solucionada por el motor de base de datos segn la conclusin que tuvimos hoy (ayer).</p>
</li>
<li>
<p>A m esta solucin me parece ms simple, sera el pluginRoot el que implementa la interfaz TransactionSender como pensaba inicialmente.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Dejo a su eleccin la implementacin que considere mejor (si agregar lo del transaction manager o dejar simplemente la intefaz transaction sender). Como dije, yo prefiero la segunda opcin.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
En ambos casos hay que tratar lo que escrib <a href="#Transaction-Transference-Protocol-v2-NotaParaLuis">abajo</a>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_analizar">Analizar</h4>
<div class="ulist">
<ul>
<li>
<p>Se pueden fusionar el Monitor y el RelayAgent en un slo thread?</p>
<div class="ulist">
<ul>
<li>
<p>Preferimos no hacerlo al menos para esta versin. En teora podra hacerse.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Analizar si pude quitarse el parmetro Specialist al mtodo <code>getPendingTransactions</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="Transaction-Transference-Protocol-v2-NotaParaLuis">Nota para Luis</h4>
<div class="paragraph">
<p>Tuve que mirar el cdigo de la parte de base de datos. No s si alguien ms aparte de m est trabajando con cosas multithread pero dejo un par de aclaraciones de lo que veo.
La versin corta es que hay que cambiar un par de lineas de un archivo del plugin de base de datos, la explicacin del por qu la dejo ac abajo.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Si bien a nivel de SQL las cosas pueden tener locks y dems mecanismos de concurrencia, lo que manejamos desde otros plug-ins es una abstraccin, por ende si alguna variable de clase (member) es usada por los mtodos que implementan estas abstracciones entonces sern compartidas por los threads que usen un mismo objeto.<br></p>
</li>
<li>
<p>Si un mtodo que es llamado por varios threads accede a una tabla (un objeto DatabaseTable), uno puede crear una instancia de DatabaseTable nueva en cada llamada del mtodo para que estos no compartan variables de las abstracciones (ac la abstraccin es el objeto DatabaseTable). Es decir hacer algo as:</p>
<div class="literalblock">
<div class="content">
<pre>public void metodoCompartido(){
   DatabaseTable t = this.database.getTable(Nombre_de_la_tabla);
   ...
   Manipulan la tabla
   ...
}</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Eso puede dar la impresin de resolver el tema, pero si uno presta atencin se usa una variable de la clase para acceder a una nueva tabla (la variable referenciada como <code>this.database</code>)<br>
El cdigo del mtodo getTable de la clase Database est <a href="https://github.com/bitDubai/fermat-pip-android-addon-os-android-database-system-bitdubai/blob/master/src/main/java/com/bitdubai/android_fermat_pip_addon_layer_2_os_file_system/version_1/structure/AndroidDatabase.java#L116">aqu</a>, como vemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>    /**
     * &lt;p&gt;Return a DatabaseTable definition
     *
     * @param tableName name database table using
     * @return DatabaseTable Object
     */
    @Override
    public DatabaseTable getTable(String tableName){

        databaseTable = new AndroidDatabaseTable(this.context,this.Database, tableName);

        return databaseTable;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>La variable databaseTable es un miembro de la clase, por lo que sera compartidas por distintos threads.<br>
Eso a mi entender trae problemas porque si dos threads llaman a mtodos que requieren tablas distintas de la misma base de datos tendra trazas que hacen que el pedido de un thread pise al del otro (debido a esa asignacin previa al return).<br>
Esto hara que necesite no slo obtener la tabla dentro de un mtodo compartido por varios threads sino que tambin hace que tenga que abrir la base de datos en el inicio de cada llamada a un mtodo de ese estilo.<br>
Afortunadamente el mtodo <code>openDatabase(UUID ownerId, String databaseName)</code> del DatabaseSystem no usa miembros de clase y slo usa variables locales por lo que parece ser thread safe (por lo que el problema no escalara otro nivel ms). El cdigo es <a href="https://github.com/bitDubai/fermat-pip-android-addon-os-android-database-system-bitdubai/blob/master/src/main/java/com/bitdubai/android_fermat_pip_addon_layer_2_os_file_system/version_1/structure/AndroidPluginDatabaseSystem.java#L28">este</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>    @Override
    public Database openDatabase(UUID ownerId, String databaseName) throws CantOpenDatabaseException, DatabaseNotFoundException {
        try{
            AndroidDatabase database;
            String hasDBName = hashDataBaseName(databaseName);
            database = new AndroidDatabase(this.Context, ownerId, hasDBName);
            database.openDatabase(hasDBName);

            return database;
        }
        catch (NoSuchAlgorithmException e)
        {
            throw new CantOpenDatabaseException();
        }

    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ms all de eso, analic el cdigo problemtico del AndroidDatabase (la clase que implementa la interfaz Database para Android) y en mi opinin cambiando el cdigo de la implementacin de la base de datos que dice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>    public DatabaseTable getTable(String tableName){

        databaseTable = new AndroidDatabaseTable(this.context,this.Database, tableName);

        return databaseTable;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>por simplemente</p>
</div>
<div class="literalblock">
<div class="content">
<pre>public DatabaseTable getTable(String tableName){
    return new AndroidDatabaseTable(this.context,this.Database, tableName);
}</pre>
</div>
</div>
<div class="paragraph">
<p>se arregla la necesidad de que tenga que abrir la base de datos en cada mtodo. La variable que se asigna en ese cdigo es variable de clase (miembro), pero no es usada en ningn otro lado. Igual pedira que lo revise alguien que entiende mejor el plug-in (yo slo navegu un par de clases).<br></p>
</div>
<div class="paragraph">
<p>Yo implement los mtodos abriendo la tabla para generar una copia exclusiva para cada thread, pero si mi razonamiento es correcto hay que corregir el cdigo de la base de datos que menciono.<br></p>
</div>
<div class="paragraph">
<p>Si mi razonamiento es erroneo, me disculpo por el tiempo que pueda haber llevado leer mi anlisis.</p>
</div>
<div class="paragraph">
<p>Luego vi que pasa algo similar con el mtodo</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>    @Override
    public DatabaseTransaction newTransaction(){

        return databaseTransaction = new AndroidDatabaseTransaction();
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aqu la variable <code>databaseTransaction</code> se usa en otra parte, pero parece ser innecesaria tambin. Esa preferira que tambin la revisen. Aunque en este caso no s si sera probelmtico (no revis el cdigo de las transacciones).</p>
</div>
<div class="paragraph">
<p>Por ltimo intent analizar el mtodo <code>executeTransaction</code> de la clase AndroidDatabase, excede mis conocimientos saber si hay problemas all. Se referencia a una variable que es miembro de la clase (es decir, una que no es variable local del mtodo y por ende podra ser compartida por varios threads al invocarlo), pero esa variable es una referencia a una instancia de la clase SQLiteDatabase, con la cual no estoy familiarizado.</p>
</div>
</div>
<div class="sect3">
<h4 id="_consultar">Consultar</h4>
<div class="ulist">
<ul>
<li>
<p>Consultar a Rodrigo la longitud de un hash de una transaccin crypto para almacenar en la base de datos del Regysty.</p>
</li>
<li>
<p>Consultar a Rodrigo la longitud de una direccin bitcoin de una transaccin crypto para almacenar en la base de datos del Regysty.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_plug_ins_in_this_layer_9">Plug-ins in this layer</h4>

</div>
</div>
<div class="sect2">
<h3 id="_incoming_crypto">Incoming Crypto</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_17">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="FermatDMP-CryptoTransactionLayer-IncomingCrypto-Bitdubai-1">Incoming Crypto - Version 1</h5>
<div class="sect5">
<h6 id="_plug_in_description_6">Plug-in Description</h6>
<div class="paragraph">
<p>Crypto networks use transactions to send value (crypto currency) from a user to another. We will use the term <strong>crypto transaction</strong> to refer to this kind of transactions.<br>
We will use the term <strong>transaction</strong> to refer to the duty of updating balances of wallets and volts to reflect the new value that arrived from the crpto transaction.<br>
It is clear that every crypto transaction produce a transaction.<br></p>
</div>
<div class="paragraph">
<p>When new crypto transactions arrive to a wallet of the user logged in the device, one plug-in must update the corresponding wallet and crypto volt balances, i.e. apply the transaction.<br>
The plug-in that receive a crypto transaction is responsible of the associated transaction until it applies the said updates or it handles the transaction to another plug-in who knows how to manage it.<br>
The plug-ins that receive the crypto transaction (e.g. crypto networks and external wallets supported by the world layer) don&#8217;t know how to apply the transactions and neither who is responsible of applying them. The purpose of this plug-in is then, to take the responsibility of the transactions from the initial plug-ins, decide what kind of plug-in should handle them and notify them trough an event so he can transfer this more specific plug-ins the responsbility of applying them.<br></p>
</div>
<div class="paragraph">
<p>In other words, this plug-in works as a router. Its purpose is to listen to two events named IncomngCryptoReceivedEvent and IncomingCryptoReversedEvent from diferent sources.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The IncomingCryptoReceivedEvent event informs that new transactions of crypto currency arrived to some wallet of the user logged in the device.<br></p>
</li>
<li>
<p>The IncomingCryptoReversedEvent event informs that a transaction that has been notfied has been reversed.<br></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that an IncomingCryptoReceivedEvent and a IncomingCryptoReversedEvent may be associated to the same crypto transaction but they produce two transactons (one to apply the crypto transaction and one to take back the changes).<br>
The plug-in must listen to this events, take the transactions from the source and take the responsability of giving this transactions to specialized plug-ins who know how to handle them.<br></p>
</div>
<div class="paragraph">
<p>We need to implement a transaction transference protocol described in the <a href="#Fermat-DMP-CryptoTransactionLayer">crypto transaction layer</a>, and also a policy to inform the arrival of new transactions, so we will need to design a mechanism of syncronization to coordinate the system actions.<br></p>
</div>
</div>
<div class="sect5">
<h6 id="_notas_to_be_translated_edited_and_deleted">NOTAS (TO BE TRANSLATED, EDITED AND DELETED)</h6>
<div class="paragraph">
<p>Cuando llega el dinero en este sistema distribuido, los dispositivos pueden estar prendidos o no. Adems no sabemos si primero llega la informacin de la transaccin o el valor de la misma.
Cuando llega primero el valor, no queda claro de quin proviene ni qu tipo de usuario lo envi (device,intra,extra user). Por eso este mdulo existe, escucha eventos de crypto que llega y su misin es tomar pocesin de la transaccin y luego pasrsela a uno de los mdulos ms especializados (incoming-crypto-device, incoming-crypto-i BTC, incoming-crypto-extra).</p>
</div>
<div class="paragraph">
<p>Crypto network, billeteras externas</p>
</div>
<div class="paragraph">
<p>El msulo recibe el evento, averigua su fuente y comienza una especie de protocolo para hacerse cargo de la transaccin y luego avisarle a quien le envi el evento que ya tom la posta y ahora se encarga l.</p>
</div>
<div class="paragraph">
<p>Si llega 1 BTC a la crypto network, cuando llega ese bitcoin el mdulo de la crypto network asume que es responsable de ese valor. Entonces emite un evento que avisa que lleg ese dinero hasta que alguien tome el control de la transaccin.</p>
</div>
<div class="paragraph">
<p>El incoming crypto escucha el evento, toma el control de la transaccin, avisa a la crypto network que ya la tiene y la crypto network deja de enviar el evento por dicha transaccin.</p>
</div>
<div class="paragraph">
<p>Todas las confirmaciones se hacen cuando las cosas se grabaron persistentemente, no cuando las toman en memoria.</p>
</div>
<div class="paragraph">
<p>Cosas similares se hacen para averiguar de qu tipo de usuario viene la transaccin para pasarle la pocesin a ese mdulo.</p>
</div>
<div class="paragraph">
<p>Los transaction managers los deben implementar tambin los mdulos que lanzan estos eventos que informan transacciones.</p>
</div>
<div class="paragraph">
<p>Cuando el mdulo especializado en el tipo de usuario escucha el evento del incoming crypto y toma responsabilidad de la transaccin. Luego aplica las acciones que sean necesarios para actualizar el estado de las billeteras y otros mdulos para que reflejen la llegada de la transaccin.<br>
Deben reflejarse los aspectos de informacin y valor. La informacin est en las wallets en general y el valor en la crypto volt (bbeda)</p>
</div>
<div class="ulist">
<div class="title">Eventos</div>
<ul>
<li>
<p>Identify: se ve una transaccin en la red pero sin confirmaciones</p>
</li>
<li>
<p>Received: la transaccin obtiene la primer confirmacin</p>
</li>
<li>
<p>ReceptionConfirmed: la transaccin es totalmente confirmada (en bitcoin son 6 confirmaciones)</p>
</li>
<li>
<p>Reversed: La transaccin fue revertida</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">IncommingCryptoRegister Table Fields</div>
<ul>
<li>
<p>Id: identificadr</p>
</li>
<li>
<p>AddressTo: Direccin de destino de la transaccin</p>
</li>
<li>
<p>CryptoCurrency: Enum de la crypto</p>
</li>
<li>
<p>CryptoAmount: Cantidad de crypto</p>
</li>
<li>
<p>Source: Direccin de origen de la transaccin</p>
</li>
<li>
<p>Destination: Debe ser origen en realidad, intra/device/extra user para saber a quin avisar sobre la transaccin</p>
</li>
<li>
<p>CryptoStatus: Estado de la transaccin en la red crypto</p>
<div class="ulist">
<ul>
<li>
<p>IDENTiFY: Se ve la transaccin en la red sin confirmaciones (no actuar)</p>
</li>
<li>
<p>RECEIVED: Ve la transaccin con una confirmacin (hacer las actualizaciones)</p>
</li>
<li>
<p>CONFIRMED: Ve la sexta confirmacin</p>
</li>
<li>
<p>REVERSED: Se revierte la transaccin, es raro pero puede pasar (considerar como revertir las cosas)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Status: Ciclo de vida del protocolo</p>
<div class="ulist">
<ul>
<li>
<p>COLOCAR LOS ENUMS</p>
</li>
</ul>
</div>
</li>
<li>
<p>Timestamp: marca de tiempo</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">IncomingCryptoEventsRecorded Table Fields</div>
<ul>
<li>
<p>Id</p>
</li>
<li>
<p>Event</p>
</li>
<li>
<p>Source</p>
</li>
<li>
<p>Status</p>
</li>
<li>
<p>Timestamp</p>
</li>
</ul>
</div>
<div class="sect6">
<h7 id="_agentes">AGENTES</h7>
<div class="paragraph">
<p>Monitor: Procesa los eventos que registra en recorderService<br>
Se despierta peridicamente y mira si hay evento que le interese.<br>
Si hay eventos sobre los que deba actuar (con next pending event?, un confirmed por ejemplo) el agente procede a tomar la posecin de la transaccin.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La clase root inicializa los agentes y el eventRecorderService.</p>
</li>
<li>
<p>El monitor se despierta, pide al registry el siguiente evento a tratar.</p>
<div class="ulist">
<ul>
<li>
<p>Si tiene algo, busca el source del evento, se comunica por la interfaz del source para pedirle el registo de las transacciones y hace lo que corresponda. Al parece lo que corresponde es tomar la informacin de la transaccin y avisarle al source que la capa de transacciones se va a hacer cargo desde ahora.</p>
</li>
<li>
<p>Si no tiene eventos, se duerme de nuevo.</p>
</li>
</ul>
</div>
</li>
<li>
<p>El relay, le pide al registry las transacciones de las que la capa es responsable (las que recibe el monitor). Consulta si viene de un intra, extra o device user y manda un evento adecuado para que lo procece el mdulo correspondiente (incoming crypto intra, incoming crypto extra, outgoing crypto intra, etc.).</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_outgoing_crypto">Outgoing Crypto</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_18">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_15">Version 1</h5>
<div class="sect5">
<h6 id="_plug_in_description_7">Plug-in Description</h6>
<div class="paragraph">
<p>Cuando el usuario hace un envo de dinero a travs de la bitcoin wallet, se invoca a este plug-in para que ejecute el envo pedido y para que actualice los balances de la wallet.<br>
Cuando se invoca a este mdulo conceptualmente se crea una transaccin a ejecutar, la cul debe mantener consistente tanto el estado del balance de la wallet como el estado de los fondos en la crypto red. <br>
El balance es llevado por el plug-in BitCoinWalletBasicWallet mientras que el envo que se hace en la red es llevado por el plug-in CryptoVault de la red bitcoin.<br></p>
</div>
<div class="paragraph">
<p>Cuando se desea hacer un pago a una wallet se le pide a este plug-in un TransactionManager. Este objeto implementa un mtodo de envo de bitcoins que requiere como parmetros el ID de la wallet que se usa para enviar el dinero, la direccin de destino y el monto a enviar.<br></p>
</div>
<div class="paragraph">
<p>El TransactionManager debe buscar a la wallet indicada, actualizar su balance y enviar el monto por la red bitcoin.<br>
Si bien esto parece simple, debemos considerar varias posibles fallas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Que el sistema se caiga en cualquier punto de las actualizaciones.</p>
</li>
<li>
<p>Que no se pueda enviar la transaccin bitcoin por la red por cuestiones diversas (imposibilidad de conectarse a la red, direccin ingresada con formato erroneo).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando se entrega un transaction manager para una wallet se debera abrir una base de datos que tiene el registro de las transacciones creadas con un estado asociado.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>NEW (NEW): Cuando el usuario ejecuta el envo del pago</p>
</li>
<li>
<p>PERSISTED_IN_WALLET (PIW): Cuando hemos persistido exitosamente el cambio del balance en la bitcoin wallet</p>
</li>
<li>
<p>SENT_TO_CRYPTO_VOULT (STCV): Cuando se envi correctamente por la red bitcoin.</p>
</li>
<li>
<p>SUCCESSFUL_SENT (SS): Cuando se registr el envo en la red.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A futuro:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>REVERSED (REV): Cuando la vault avisa que se revers la transaccin enviada (la vault se encarga de reenviarla)</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fermat_dap_system_layers">Fermat-DAP System Layers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(SECCION PARA SER COMPLETADA POR EL EQUIPO DE DAP+ NOTA DE FERMAT-BOOK-MANAGER (<a href="mailto:book@fermat.org">book@fermat.org</a>) 27-9-2015)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fermat_dap_actor">FERMAT-DAP /actor</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="actor-asset-issuer-BitDubai-V1">Version 1</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_plug_in_description_8">Plug-in Description</h3>

</div>
<div class="sect2">
<h3 id="_plug_in_structure_2">Plug-in Structure</h3>

</div>
<div class="sect2">
<h3 id="_events_2">Events</h3>

</div>
<div class="sect2">
<h3 id="_implementation_details_2">Implementation Details</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="actor-asset-user-BitDubai-V1">Version 1</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_plug_in_description_9">Plug-in Description</h3>

</div>
<div class="sect2">
<h3 id="_plug_in_structure_3">Plug-in Structure</h3>

</div>
<div class="sect2">
<h3 id="_events_3">Events</h3>

</div>
<div class="sect2">
<h3 id="_implementation_details_3">Implementation Details</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="wallet-module-asset-user-BitDubai-V1">Version 1</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_plug_in_description_10">Plug-in Description</h3>

</div>
<div class="sect2">
<h3 id="_plug_in_structure_4">Plug-in Structure</h3>

</div>
<div class="sect2">
<h3 id="_events_4">Events</h3>

</div>
<div class="sect2">
<h3 id="_implementation_details_4">Implementation Details</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="identityPublicKey-asset-issuer-BitDubai-V1">Version 1</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Esta Plugin Asset Factory de naturaleza CRUD, su funcin principal es la, modificacin, y listado del Asset en su etapa de fabricacin, para que pueda ser consultados en toda sus etapas,
y poder actualizar sus propiedades, siempre y cuando este en "state" <em>Draft</em>.</p>
</div>
<div class="sect2">
<h3 id="_plug_in_description_11">Plug-in Description</h3>
<div class="paragraph">
<p>Este pluggin pedira las siguiente propiedades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Identity Asset Issuer: Identity del Actor AssetIssuer</p>
</li>
<li>
<p>String name: nombre del Asset definido por el issuer.</p>
</li>
<li>
<p>String description: descripcin del asset definido por el issuer.</p>
</li>
<li>
<p>List&lt;Resource&gt;: lista de recursos posibles del asset, como por ejemplo imgenes, videos, etc.</p>
</li>
<li>
<p>String GenesisTransaction: hash de la transaccin bitcoin donde el asset est incluido.</p>
</li>
<li>
<p>Address GenesisAddress: direccin Genesis generada por la Asset Vault</p>
</li>
<li>
<p>Cantidad de Assets que se estn creando (DigitalAsset.quantity)</p>
</li>
<li>
<p>Valor de cada Asset. (DigitalAsset.unitValue)</p>
</li>
<li>
<p>Valor del Fee de cada transaccin. (DigitalAsset.transactionFee).</p>
</li>
<li>
<p>long GenesisAmount: valor crypto del digital asset en Satoshis.
<strong>DigitalAsset.quantity * DigitalAsset.unitValue + ( DigitalAsset.transactionFee * DigitalAsset.quantity)</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El Issuer debe determinar el calculo del transactionFee, llamando un metodo de la cryptoVault getEstimatedFeeValue, y tambien chequear que hayan fondos disponibles para cubrir el GenesisAmount.</p>
</div>
<div class="paragraph">
<p>Una vez que todas las validaciones anteriores esten correctas debemos de comenzar el envio a la capa transaccional con el metodo IssueAsset(DigitalAsset digitalAsset) y setear el "state" a <em>PendingFinal</em>,
y luego cuando tengamos el GenesisTransaction y GenesisAddress, procedemos actualizarlo en el Digital Asset del Factory y el "state" a <em>Final</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_plug_in_structure_5">Plug-in Structure</h3>

</div>
<div class="sect2">
<h3 id="_events_5">Events</h3>

</div>
<div class="sect2">
<h3 id="_implementation_details_5">Implementation Details</h3>

</div>
<div class="sect2">
<h3 id="best-practices">Best Practices</h3>
<div class="paragraph">
<p><a href="https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/">https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/</a></p>
</div>
<div class="paragraph">
<p><a href="http://blog.jooq.org/2013/08/20/10-subtle-best-practices-when-coding-java/">http://blog.jooq.org/2013/08/20/10-subtle-best-practices-when-coding-java/</a></p>
</div>
<div class="paragraph">
<p>Definamos lo todo lo conveniente.</p>
</div>
</div>
<div class="sect2">
<h3 id="_consideraciones_para_dap">Consideraciones para DAP</h3>
<div class="ulist">
<ul>
<li>
<p>Crear una DAPException para poder manejar todo tipo de Exception que se presente</p>
</li>
<li>
<p>Validar todos los SET y GET con THROWS para asegurar que tengan valores y no se generen
Excepciones desencadenadas de NULL</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_uso_de_getters">Uso de "getters"</h4>
<div class="paragraph">
<p>Todos los mtodos getters deben usar en la Digital Asset Platform deben seguir el siguiente formato:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="java language-java">public void getSomething() throws ObjectNotSetException {

    ....
    if(returningObject==null){
        throw new ObjectNotSetException("The object to get is null", "getSomething() method in DAPClass", "Some description");
    }

    return returningObject

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>El objetivo de esta tcnica es evitar que los mtodos getters devuelvan null, para ello se debe realizar una verificacin previa antes de obtener algn objeto.</p>
</div>
<div class="paragraph">
<p>En el caso de implementar un mtodo get proveniente de una interfaz que no posea throws ObjectNotSetException, se recomienda usar el report manager para que quede registrada el intento de obtener un objeto que est null, por ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="java language-java">@Override
public void getSomething(){
    ...
    try{
        if(returningObject==null){
            throw new ObjectNotSetException("The object to get is null")
        }
    } catch(ObjectNotSetException exception) {
        this.errorManager.reportUnexpectedPluginException(Plugins.BITDUBAI_DAP_PLUGIN, UnexpectedPluginExceptionSeverity.DISABLES_SOME_FUNCTIONALITY_WITHIN_THIS_PLUGIN, exception);
    }
}


== Refactor Pendientes por hacer:

* Cambiar todos UUID a string las propiedades de las wallet, skin, language, ya que deberan de usar la publickey asociada.

:leveloffset: 1
= FERMAT-DAP /actor

:leveloffset: 2
[[digital-asset-transaction-asset-issuing-BitDubai-V1]]
= Version 1

Este plugin, de naturaleza transaccional, tiene por objetivo recopilar toda la informacin necesaria para la emisin de un Digital Asset.
Esta informacin, no solo contendr el detalle de la transaccin cripto (Genesis transaction) asociada al asset,
deber incluir la informacin multimedia que sirva para la construccin de la UI del Asset en el dispositivo, asi como el contrato de uso del mismo.

El plugin Asset Issuing ser el encargado de la creacin de los Assets, incluyendo metadata y crypto monto, que posteriormente sern enviados a los posibles destinatarios de los Digital Assets. Este plugin
deber solicitar la genesis transaction, la cual se define como la transaccin origen de los crypto montos a ser transferidos junto al asset, as mismo, debe solicitar
la genesis address, la cual se define como la direccin que emiti el Asset. Una vez obtenida la informacin antes mencionada, este plugin debe crear las transacciones que
permitan la transferencia de los Assets a los destinatarios. Este plugin debe ser responsable de cada uno de los Assets generados hasta que todos hayan sido entregados a los
destinatarios. Este plugin debe tener la capacidad de monitorear que Asset ha sido entregado y registrarlo, para su posterior consumo. Si un asset no hasido registrado como entregado por este plugin, ese Asset no debera ser consumido por el beneficiario.
Estos Assets pueden ser enviados a cualquier tipo de wallet, es decir, debe ser transparente para este plugin los destinatarios de los assets, la metadata que se entrega a
 este plugin debe incluir la informacin que permita discriminar a que tipo de wallet/destinatario va dirigido el Asset, este proceso de filtrado podra tomarse de las wallets
 instaladas actualmente, este plugin debe recibir de una capa superior el criterio de seleccin de los destinatarios, de tal forma que este pueda crear la transacin que permita
 enviar el asset al destinatario.
Los Assets que no se hayan enviado deben permanecer en el dispositivo emisor (Asset Distribution) hasta que el beneficiario haya autorizado la instalacin/descarga del digital asset
a su dispositivo. Al momento de instalacin del Asset en el dispositivo destino es que se debe realizar la trasferencia del crypto monto al dispositivo destino.
Los crypto montos del emisor asociados a cada assets deben estar reservados en el dispositivo emisor hasta que sean transferidos a los beneficiarios. Estos montos no deben
cambiar una vez reservados.

== Plug-in Description

El objeto DigitalAsset de la plataforma, contar con las siguientes propiedades:

 * Identity Asset Issuer: Identity del Actor AssetIssuer
 * String name: nombre del Asset definido por el issuer.
 * String description: descripcin del asset definido por el issuer.
 * List&lt;Resource&gt;: lista de recursos posibles del asset, como por ejemplo imgenes, videos, etc.
 * String GenesisTransaction: hash de la transaccin bitcoin donde el asset est incluido.
 * Address GenesisAddress: direccin Genesis generada por la Asset Vault
 * long GenesisAmount: valor crypto del digital asset en Satoshis.

 Digital Asset Contract (DAC)

Como contrato bsico para el Digital Asset para poder cerrar el ciclo en el desarrollo inicial de la plataforma,
especificaremos que:

 * Redimible.
 * ExpirationDate: fecha de expiracin que puede ser nunca.
 * Transferible.

La emisin de un Digital Asset va a tener un enum con los siguientes estados:

* Draft: cuando el issuer est completando los datos bsicos del asset y del contrato.
* PendingFinal: cuando el issuer solicita que se arme la transaccin bitcoin y se cierre el asset.
* Final: cuando se gener el hash del DA y el Asset ya no se puede modificar.

La construccin de una Digital Asset Transaction va a tener los siguientes estados:

* Blank: estado inicial, en el cual no se ha llevado ningn proceso transaccional.
* RequestingGenesisAddress: solicitando una direccin a la cryptoVault.
* GenesisAddressObtained: la genesis address se obtuvo de la Crypto Vault.
* SendingBitcoins: estado en el cual se solicita la transferencia de fondos a la wallet Issuer.
* BitcoinsSent: La transferencia de fondos se realiz correctamente.
* ToRedeem: estado en el cual se espera el canje del Asset.
* CheckingAsset: estado en el cual se verifica la transaccin asociada al Asset.
* ReturningBitcoins: estado en el cual la genesis amount se comienza a transferir a la Wallet emisora.
* BitcoinsReturned: estado en el cual se ha completado la transferencia a la Wallet Emisora.
* Redeemed: estado en el cual el Asset se considera redimido.


Al iniciar el plugin este instancia al objeto DigitalAssetCryptoTransactionFactory, el cual ser el encargado de tomar el Digital Asset creado por AssetIssuingTransactionPluginRoot con los datos provenientes de la UI a travs del AssetIssuerModule.
DigitalAssetCryptoTransactionFactory (DACTF) usar una instancia del CryptoVaultManager para crear la genesis transaction, la cual quedar registrada en el CryptoAddressBook por medio de CryptoAddressBookManager, que se va a asociar al objeto Digital Asset y as crear un nuevo DigitalAssetMetadata, este ltimo objeto debe generase al concluir
el proceso de creacin del digital Asset, ya que este es quien ajustara el estado a _final_, una vez que se encuentra en este estado ya no se debe modificar ninguna caracterstica del Digital Asset.

=== Pasos detallados:

Diagrama de Flujo en Prezi: http://prezi.com/fy3cag7olwbz/?utm_campaign=share&amp;utm_medium=copy&amp;rc=ex0share

1) La AssetIssuer subApp, a travs de un wizard solicitar los datos bsicos necesarios para la creacin del asset. En el mismo se
 realizarn distintas especificaciones del asset y el contrato inicial.



 La Asset Factory debe mostrar al usuario el monto final de la transaccin bitcoin (GenesisAmount) para su aprobacin mediante
 el uso de los siguientes campos:
* Cantidad de Assets que se estn creando (DigitalAsset.quantity)
* Valor de cada Asset. (DigitalAsset.unitValue)
* Valor del Fee de cada transaccin. (DigitalAsset.transactionFee).

El valor del GenesisAmount se calcular de la siguiente forma:

 *DigitalAsset.quantity * DigitalAsset.unitValue + ( DigitalAsset.transactionFee * DigitalAsset.quantity)*

El DigitalAsset.transactionFee es un valor que calcular la cryptoVault a travs del mtodo getEstimatedFeeValue.

La Issuer subApp no permitir iniciar el proceso de issuing del Asset si no dispone los fondos disponibles para cubrir el GenesisAmount.

Todos los procesos de generacin y edicion del Asset sern persistidos en el plugin Middleware Asset Factory. Al momento de finalizar con la
edicin y dar comienzo a la transaccin de Asset Issuing, el mismo ya dejar de estar editable en la sub App del issuer.

La transaccin de Asset Issuing se dar inicio a travs del mtodo IssueAsset(DigitalAsset digitalAsset).

1) El primer paso es asegurarse que el DigitalAsset (DA) est completo en todos sus campos y contrato. Las nicas propiedades que no deben estar completas son GenesisTransaction y
GenesisAddress.

2) Al estar todo completado para emitir el Asset, se persiste el DA (en archivo) y se actualiza el TransactionStatus a FormingGenesis.
El asset guardado en la Asset Factory pasa a estado final y no puede volver a ser modificado en la subApp Issuer.

3) Se llama al mtodo generateEmptyTransactionHash() de la CryptoVault que devolver un String con el Hash de la genesis Transaction. El especialista de la transaccin
para a ser en este momento la CryptoVault hasta que devuelve el valor esperado. Se actualiza este valor en el DA y se persisten los cambios.

4) Se llama al mtodo requestGenesisAddress de la AssetWallet y se persistir este valor en la GenesisAddress. Esta solicitud de direccin
debe ser registrada en el CryptoAddressBook a travs del mtodo registerCryptoAddress.

5) Se crear el objeto DigitalAssetMetadata y se generar el hash del DA con el mtodo getDigitalAssetHash. La transaccin pasara a estar en estado PendingSubmitCryptoNetwork.

6) Se enviar la transaccin a travs de la cryptoVault utilizando el metodo send de la CryptoWallet y se pasan los siguientes valores:

* transactionId: el obtenido en el paso 3.
* addressTo: la obtenida en el paso 4.
* OP_RETURN: el hash del objeto DigitalAssetMetadata (DigitalAssetMetadata.getDigitalAssetHash())
* Amount: el valor calculado en el punto 1.

La transaccin pasa a estado PendingReceiveCryptoNetwork

7) Al momento de ingresar la transaccin bitcoin a travs de la crypto Network, la transaccin pasa a estado PendingConfirmCryptoNetwork y ejecutamos un crdito en el book
balance de la Asset Wallet. En este momento, el DigitalAssetMetadata queda persistido en la Asset Wallet. La transaccin debe escuchar los eventos
del incoming crypto.



8) Al confirmarse la transaccin en la cryptoNetwork la transaccin pasa a estado PendingConfirmationIssuerWallet y se genera el crdito  en el Available balance en la
Issuer Wallet.

9) La issuerWallet genera un crdito en el available balance de la wallet y confirma que toma posesin del DA.

10) La transaccin finaliza y actualiza a Finalized.

== Plug-in Structure

== Events

== Implementation Details


:leveloffset: 2
[[digital-asset-transaction-incoming-issuer-BitDubai-V1]]
= Version 1
    Por definir.
= Plug-in Description

= Pasos detallados

Diagrama de flujo en Prezi: http://prezi.com/_mbtb0pa22c3/?utm_campaign=share&amp;utm_medium=copy&amp;rc=ex0share

.Escenario:


Nos encontramos con balance positivo en la Asset Wallet de al menos un asset disponible. Esto significa que disponemos del objeto _DigitalAssetMetadata_ persistido
en la wallet y bitcoins en la Asset Vault (Ver &lt;&lt;digital-asset-transaction-asset-issuing-BitDubai-V1,Asset Issuing Transaction&gt;&gt; ) suficientes para transferir el asset la cantidad de veces que sea necesaria.

Al tener instalada en el dispositivo la Issuer Wallet, el &lt;&lt;actor-asset-issuer-BitDubai-V1, Actor NetworkService Issuer&gt;&gt; ha comenzado a solicitar al Communication Server
la lista de Asset Users disponibles y persiste esta informacin en su base de datos. Entre otros datos, se guarda la direccin Bitcoin de cada user.

Es decir, tenemos balance positivo y una lista de usuarios a quienes enviar el asset.

En la reference Wallet del Asset Issuer se ha seleccionado enviar el asset (o los assets) a ciertos usuarios, lo cual inicia la transaccin Asset Distribution
con los siguientes pasos:

1) Se llama al mtodo distributeAsset (String assetPublicKey, List&lt;AssetUser&gt; assetUsers) que inicia la transaccin recibiendo el id del asset a distribuir y
la lista de usuarios a distribuir. El estado de la transaccin se actualiza a PendingVerify

2) Se debe verificar que el Asset no ha sido modificado externamente y que sigue siendo vlido comparando el Hash del Asset con el Hash guardado en la Genesis Transaction.
Para ello, se obtiene el hash de la genesis transaction invocando al mtodo getAssetHash(transactionId genesisTransaction) de la AssetVault.

Si la comparacin entre el _DigitalAssetMetadata_ es igual a la obtenida por la Asset Vault, entonces el asset es vlido sigue siendo vlido.

3) Debemos verificar que seguimos disponiendo fondos suficientes en la Asset Vault para transferir los assets invocando al mtodo _getAssetVaultBalance_ de la Asset Vault
 y verificando que disponemos de un balance superior al GenesisAmount del DA.

TIP: En esta etapa, el asset es vlido para ser transferido y la transaccin pasa a estado VerifyCompleted.

4) Lo siguiente ocurre por cada AssetUser a quien se transfiera. El objeto _assetUser_ va a tener la propiedad _CryptoAddress_ con la direccin bitcoin propia.

IMPORTANT: La AssetDistribution transaction debe mantener un registro por cada transaccin de envo a Asset Users. La transaction macro de envo de/l asset/s
se descompone en tantas transacciones como usuarios a enviar existan.

.*En el dispositivo del Asset Issuer*

A travs del Asset Transmission NetworkService, va a transmitir el AssetMetadata especificando al AssetUser llamando al mtodo:
[source, java]
UUID distributeAssetToAssetUser(DigitalAssetMetadata, AssetUser);

Esta llamada ser en forma asincrnica y su valor de retorno ser un _DistributionId_ para persistir esta informacin y aguardar a que obtengamos el ok desde el Asset User networkService.

.*En el dispositivo del usuario*

El ActorNetworkService Asset User recibe el mensaje con el _DigitalAssetMetadata_ para validarlo y ejecuta lo siguiente:

* El UUID generado por _distributeAssetToAssetUser_ ser persistido localmente para mantener un registro del ID de transaccin y poder informar
luego el resultado.

Validacin de _DigitalAssetMetadata_

* Verifica que el Asset es vlido buscando en la blockChain la GenesisTransaction y obteniendo el hash del DigitalAsset. Compara el hash
obtenido con el generado por el _DigitalAssetMetadata_.getDigitalAssetHash. Si los valores son iguales el DA es vlido.
* Verifica que el contrato del Digital Asset cumple con las propiedades. Es decir,
[source, java]
DigitalAssetContract.getContractProperty(DigitalAssetContractPropertiesConstants.EXPIRATION_DATE)

est dentro de la fecha vlida.

* Infoma a travs del NetworkService AssetUser que el AssetMetadata es vlido informado el status completed del _DistributionId_ pasado originalmente.
En caso de error o que el asset no es vlido o no cumple el contrato, se informa igualmente para cerrar esta transaccin.

* De ser aceptado, el _DigitalAssetMetadata_ es persistido en la UserWallet sin actualizar an balance ya que es medio asset.

* Informa a travs del Asset User NetworkService pasando el _DistributionId_ y el status de ok para informar fin del proceso.

.*En el dispositivo del Asset Issuer*

El network Service del AssetUser retorna mensaje de OK o fallido para el _DistributionId_ generado y ocurre lo siguiente:

* Si no se acept el _DigitalAssetMetadata_, esta transaccin se marca fallida y se cierra.
* Si se acept el _DigitalAssetMetadata_ entonces lo siguiente ocurre:
** Se envan los Bitcoins a travs de un mtodo de la AssetVault llamando al mtodo:
[source, java]
sendAssetBitcoins (long amount, CryptoAddress sendTo, String AssetPublicKey)

 El *Amount* es la cantidad de satoshis del Asset que se obtiene de la propiedad DigitalAsset.getUnitValue()

 El *sentTo* es la direccin del AssetUser que la obtuvimos al inicio a travs del ActorNetworkService Asset Issuer.

 El *AssetPublicKey* es el Id del asset que se obtiene de DigitalAsset.getPublicKey().

Esto genera una nueva transaccin en la AssetVault que colocar el PublicKey del asset dentro de la transaccin (*Output OP_RETURN*) y la enviar al usuario.

** Se genera un dbito en la Issuer Wallet que indica que el Asset ha sido enviado tanto en su metadata como los bitcoins.

** Cuando luego la transaccin bitcoin sea confirmada en la red por un bloque, se actualizar el balance available.

.*En el dispositivo del usuario*
* El Agent IncomingCrypto detectar el ingreso de los bitcoins y como la direccion a la que llegan est registrada a travs del Address Book
se informar un evento que la Asset User Wallet escucha.
* La Asset User Wallet obtendr de la transaccin bitcoin que lleg la publicKey del asset buscando el output del tipo OP_RETURN para machearlo con la _DigitalAssetMetadata_ que
ya tiene guardada del paso anterior y actualizar el book balance.
* Cuando esta transaccin bitcoin se confirme, actualizar el available balance de la wallet.


Si la conexin con el AssetUser no estaba abierta, entonces esta transmisin ser marcada como fallida y se tendr que reintentar ms adelante.
Una propiedad en la Issuer Reference Wallet  definir estos parmetros de retry.

Si el _DigitalAssetMetadata_ no fue aceptado, esta transmisin ser marcada como erronea y no se volver a reintentar.




== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 2
[[digital-asset-transaction-asset-redemption-BitDubai-V1]]
= Version 1

== Plug-in Description

Transaction Flow on Prezi: https://prezi.com/jwnuv7i13mnb/dap-asset-redemption/

.Escenario:

Nos encontramos en el dispositivo del usuario con al menos un asset disponible en su Asset User Wallet y los fondos necesarios en su Asset Vault
para al menos pagar el fee de una transaccin.

El asset se encuentra confirmado y el Asset est disponible en el available Balance.

En la Asset user Reference Wallet el usuario tiene disponibles algunos Redeem Point obtenidos automticamente por el Redeem Point Network Service.
El usuario selecciona el que tiene ms cerca y se dirige a ese Redeem Point.

El redeem point seleccionado, tiene direcciones bitcoin generadas en forma independiente, a partir de una extended key enviada por el issuer.

Para redimir el asset en ese Reedem Point especifico el usuario pulsa la opcion Redeem habiendo seleccionado el Redeem Point correspondiente.

La transaccin Asset Redemption ejecuta los siguientes pasos:

Se repiten los mismos pasos de la transaccin Asset Distribution, con la diferencia que el asset se enva a un redeem point pero bsicamente.

1) Verifica que el contrato del Asset permite que sea redimible. Luego valida que el Asset a enviar sigue siendo vlido y no fue modificado.

2) Enva la metadata al Redeem Point para que haga las validaciones correspondientes del contrato.

3) Si es aceptado, hace el envo de bitcoins y genera el dbito en la User Wallet.

4) El redeem point recibe los bitcoins con el asset publicKey en el output y marca genera el crdito en la Redeem Point wallet.

5) En el Asset Issuer se reciben tambin los bitcoins y se tiene registrada que la direccin a la que fueron enviados a que rama del rbol HD corresponden.
Con esta informacin, actualiza la estadstica de la redimicin de assets en la Issuer SubAp. Los bitcoins ingresados son enviados en una nueva transaccin a la crypto Vault
ya que no pertenecen a ningn asset.

== Plug-in Structure

== Events

== Implementation Details


:leveloffset: 1
[line-through]#[[flujo-general-BitDubai-V1]]

= Flujo General de la Plataform DAP

= Flujo Desarrollo

El flujo de desarrollo del Asset describe lo necesario para generar un Digital Asset.

  Objeto Digital Asset (DA)

El objeto DigitalAsset de la plataforma, contar con las siguientes propiedades:

 * Identity Asset Issuer: Identity del Actor AssetIssuer
 * String name: nombre del Asset definido por el issuer.
 * String description: descripcin del asset definido por el issuer.
 * List&lt;Resource&gt;: lista de recursos posibles del asset, como por ejemplo imgenes, videos, etc.
 * String GenesisTransaction: hash de la transaccin bitcoin donde el asset est incluido.
 * Address GenesisAddress: direccin Genesis generada por la Asset Vault
 * long GenesisAmount: valor crypto del digital asset en Satoshis.

 Digital Asset Contract (DAC)

Como contrato bsico para el Digital Asset para poder cerrar el ciclo en el desarrollo inicial de la plataforma,
especificaremos que:

 * Redimible
 * ExpirationDate: fecha de expiracin que puede ser nunca.
 * Transferible _(es bueno plantearlo desde la versin inicial para poder establecer a los responsables del proceso de traspaso de propiedad del Digital Asset)_

La emisin de un Digital Asset va a tener un enum con los siguientes estados:

* Draft: cuando el issuer est completando los datos bsicos del asset y del contrato.
* PendingFinal: cuando el issuer solicita que se arme la transaccin bitcoin y se cierre el asset.
* Final: cuando se gener el hash del DA y el Asset ya no se puede modificar.

== Assset Issuing

Una vez completadas estas propiedades por parte del Issuer, la Asset Issuer subApp, inicia una Digital Asset Transaction de Asset Issuing en la que lo siguiente ocurre:

* Se reciben la informacin multimedia y las caractersticas de la transaccin del Digital Asset.
* Se solicita a la Crypto Vault la creacin de una transaction bitcoin a travs del Outoing Intra user. Este hash se define como la GenesisTransaction
en el Digital Asset.
* Se solicita a la Asset Vault una direccin bitcoin que ser la GenesisAddress. Esta direccin solicitada queda registrada en el Address Book como solicitada por el Issue Actor,
la plataforma DAP y la vault de donde sale la direccin.
* Se completa la crypto transaccin especificando el GenesisAmount.
* Se ejecuta un hash del Digital Asset y el mismo se coloca en el OP_RETURN de la crypto transaccin.
* Se commitea la transaccin y la misma es publicada a la red de bitcoin a travs de la Crypto Network.
* Se asocia la metadata a la genesis transaction.
* El Digital Asset es considerado creado.
* El Digital Asset se considera available cuando la transaccin bitcoin es detectada como entrante por el Incoming Crypto. _no entiendo este paso_
* Todos los Digital Assets generados deben ser transferidos al plugin AssetDistribution, este plugin se encargar de realizar la transferencia.

 Detalles de Modulos:

 * Asset Issuer (Module)
 Registrara toda la logica intermedia, originado de la (Sub App Module), que sera expuestas para la Asset Issuet (sub app)

 * Asset Issuer (Sub App Module)
 Registrara toda la logica de negocio que seran expuestas para la Asset Issuet (module)

 * Asset User (Module)
   Registrara toda la logica intermedia, originado de la (Sub App Module), que sera expuestas para la Asset User (sub app)

 * Asset User (Sub App Module)
   Registrara toda la logica de negocio que seran expuestas para la Asset User (module)

 * Redeem Point (Module)
   Registrara toda la logica intermedia, originado de la (Sub App Module), que sera expuestas para la Redeem Point (sub app)

 * Redeem Point (Sub App Module)
   Registrara toda la logica de negocio que seran expuestas para la Redeem Point (module)
* (Manuel completar ms info de la transaccin) *

Realizadas estas operaciones, y al momento de recibir el GenesisAmount en la Asset Vault, las operaciones de crdito dentro de la
Asset Wallet deben ocurrir.


 * *Asset Issuer Wallet (wallet)*

Realizara una transaccion contable al balance (asset issuet wallet), debitando la cantidad de Asset originado en su creacion, en el momento en que
el Issuer envie un Asset a un User, este le sea acreditado dicho al (asset issuet wallet) y debitado a la (asset user wallet), de esta forma el Issuer podria determinar el balance total enviado y disponible en su Book Address,
todo esta operacion debe ser originado mediante una transaccion de la capa transaction.

* *Asset User Wallet (wallet)*

Este proceso realizara una transaccion contable a la (asset user wallet), debitando el disponible de asset, y acreditando cuando sea redimido el asset,todo esta operacion debe ser originado mediante una transaccion
de la capa transaction.

* *Redeem Point Wallet (wallet)*

Este proceso determina el intercambio de la wallet Asset User donde mediante un metodo donde se pase las direcciones correspondiente se realizara una transaccion contable a la Asset del User, disminuyendo la cantidad de la wallet Asset User,
y acreditando o retornando dicho asset a la Asset Issuer en punto Reddem Point o en alguna wallet que determine la Redemcion.
Aclarar que pasa con este Asset si se puede volver a enviar.
Una vez verificada la genesis transaction por parte del Redeem Point, se debe notificar al plugin Outgoing Issuer que debe realizar la transferencia del monto crypto asociado
a la genesis transaction haca el dispositivo que va a recibir el digital asset para su "redemcin". Una vez que se produzca la transferencia del monto del Digital Asset
el dispositivo del beneficiero del asset debe proceder a registrar el consumo del mencionado Asset y proceder a su inhabilitacin (?) del dispositivo y registrarlo como consumido.


El proceso de canje de un Asset por un servicio (Redeem Point) va a tener un enum, en el dispositivo del beneficierio, con los siguientes estados:
 * ToRedeem: cuando la Asset Wallet comienza el proceso de canje del DA.
 * Checking: cuando el DA ha sido enviado al Redeem point para su verificacin.
 * Checked: cuando el Redeem Point ha revisado el DA.
 * Acepted: cuando el RP ha validado correctamente el contrato y la transaccin del DA.
 * NotAcepted: cuando el RP ha validado la transaccin del DA pero no el contrato del mismo.
 * NotRedeemable: cuando el ha validado el contrato del DA pero no la transaccin del mismo.
 * Rejected: cuando el RP no ha validado la trasaccin del DA ni el contrato del mismo.

 En el caso del dispositivo Redeem Point, el proceso de canje de un Digital Asset incluye los siguientes estados, definidos en un enum:
 * Incoming: cuando se recibe la notificacin de un Asset entrante.
 * ToCheck: cuando el DA se ha recibido en el RP.
 * Checking: cuando el RP est verificando la informacin provista por el DA.
 * Checked: cuando el Redeem Point ha revisado el DA.
 * Acepted: cuando el RP ha validado correctamente el contrato y la transaccin del DA.
 * NotAcepted: cuando el RP ha validado la transaccin del DA pero no el contrato del mismo.
 * NotRedeemable: cuando el ha validado el contrato del DA pero no la transaccin del mismo.
 * Rejected: cuando el RP no ha validado la trasaccin del DA ni el contrato del mismo.


= Funciones del Asset Issuing

El plugin Asset Issuing ser el encargado de la creacin de los Assets, incluyendo metadata y crypto monto, que posteriormente sern enviados a los posibles destinatarios de los Digital Assets. Este plugin
deber solicitar la genesis transaction, la cual se define como la transaccin origen de los crypto montos a ser transferidos junto al asset, as mismo, debe solicitar
la genesis address, la cual se define como la direccin que emiti el Asset. Una vez obtenida la informacin antes mencionada, este plugin debe crear las transacciones que
permitan la transferencia de los Assets a los destinatarios. Este plugin debe ser responsable de cada uno de los Assets generados hasta que todos hayan sido entregados a los
destinatarios. Este plugin debe tener la capacidad de monitorear que Asset ha sido entregado y registrarlo (aun no veo donde), para su posterior consumo. Si un asset no hasido registrado como entregado por este plugin, ese Asset no debera ser consumido por el beneficiario.
Estos Assets pueden ser enviados a cualquier tipo de wallet, es decir, debe ser transparente para este plugin los destinatarios de los assets, la metadata que se entrega a
 este plugin debe incluir la informacin que permita discriminar a que tipo de wallet/destinatario va dirigido el Asset, este proceso de filtrado podra tomarse de las wallets
 instaladas actualmente, este plugin debe recibir de una capa superior el criterio de seleccin de los destinatarios, de tal forma que este pueda crear la transacin que permita
 enviar el asset al destinatario.
Los Assets que no se hayan enviado deben permanecer en el dispositivo emisor hasta que el beneficiario haya autorizado la instalacin/descarga del digital asset
a su dispositivo. Al momento de instalacin del Asset en el dispositivo destino es que se debe realizar la trasferencia del crypto monto al dispositivo destino.
Los crypto montos del emisor asociados a cada assets deben estar reservados en el dispositivo emisor hasta que sean transferidos a los beneficiarios. Estos montos no deben
cambiar una vez reservados.


= Transferencia y confirmacin de Asset a beneficiario

= Notificacin en Incoming Issuer

El plugin Incoming Issuer en el lado del consumidor o beneficiario ser el encargado de monitorear la existencia de un Digital Asset (de alguna manera, por definir) que est dirigido para la Asset Wallet del usuario,
en caso de recibir la notificacin de la existencia de un Digital Asset, este plugin deber verificar la metadata que debe estar incluida en el Asset,  esta comprobacin debe
incluir la verificacin de la genesis Transaction, con lo cual se puede verificar el origen del Asset.
Una vez verificado el origen del Asset, el plugin debe lanzar una notificacin a una capa superior para que el usuario est en cuenta de la existencia de este Asset.
Es de hacer notar que hasta el momento, se piensa que el usuario va a autorizar si el Asset va a ser descargado en el dispositivo, esto podra cambiar en un futuro,
ya que se plantea que este Asset puede estar "pre-instalado" en el dispositivo. Se podra definir varias posibles condiciones de descarga de un Asset:
 * descargable automticamente (el Issuer la instala automticamente en las Asset Wallets destino)
 * descargable por autorizacin del usuario.
 * preinstalada en la Asset Wallet.
Una vez que la Asset Wallet autoriza la instalacin o descarga del Digital Asset, se procede a crear la transaccin que va a transferir el monto crypto asociado a la metadata
de la genesis transaction a la Asset Vault del destinatario. Una vez realizada correctamente la transferencia de fondos, se debe notificar a las capas que controlan la UI la
correcta instalacin/descarga del Asset.

*Preguntar al team*:
Un asset puede ser descargado o instalado por algn otro medio distinto a la red de fermat? Se podra recibir va cdigo QR?

 = Transferencia y confirmacin del Digital Asset a Redeem Point.

El proceso de transferencia de un Digital Asset a un Redeem Point es aquel en el cual el usuario va a canjear el DA por un servicio provisto por el emisor del asset (Issuer).
Este proceso incluye la participacin del Plugin Outgoing Issuer en el dispositivo del beneficiario, el cual ser el encargado de generar la trasaccin que transferir el DA
al Redeem Point. Este plugin, una vez culminada la creacin de la transaccin para realizar el envo del Digital Asset este debe modificar el estado del DA para que los siguientes
actores de la DAP procedan a notificar al usuario su consumo o su rechazo y su eliminacin de la Asset Wallet.

#

:leveloffset: 1
= FERMAT-DAP /actor

:leveloffset: 1
[[identityPublicKey-asset-issuer-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[identityPublicKey-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details


:leveloffset: 1
= FERMAT-DAP /actor

:leveloffset: 1
[[actor-asset-issuer-BitDubai-V1]]
= Version 1

== Plug-in Description

.Relacionado al Asset User

1) Al iniciarse, solicita al Communication Server la lista de Asset Users que han notificado al servidor de su conexin.

2) Persiste en su base de datos aquellos nuevos Asset Users de los cuales no dispone registros conjuntamente con la direccin Bitcoin
de la Asset Vault.

3) Limpia de su base de datos, aquellos Asset Users que no se han conectado por ejemplo, en la ltima semana.

4) Actualiza la informacin de conexin con la fecha actual.

.Relacionado al Redeem Point

1) Al iniciarse, solicita al Communication Server la lista de Redeem Points que han notificado al servidor de su conexin.

2) Por cada Reedeem Point online al que no se haya comunicado anteriormente, solicitar a la Asset Vault la creacin de una nueva rama en el rbol de claves HD.
Creada la nueva rama, la extended public Key (que permite la generacin de claves pblicas), ser guardada en la RedeemPoint Address Book.

3) Transmitir a travs del communication server la clave pblica para que sea guardada en el Redeem Point.
Cuando una transaccin bitcoin ingrese de la rama generada por esta extended public key, se disparar el evento especifico para informar a la Asset Issuer Wallet que el Redeem Point dueo de
esa clave, redimi un asset.

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[actor-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

.Relacionado al Asset Issuer
1) Al iniciarse, notifica al Communication Server de su conexin.

2) Cuando recibe del communication Server el mensaje de registrar una nueva direccin de Bitcoin, valida que la propiedad NotifyBitcoinAddress
est en true y solicita una nueva direccin de Bitcoin a la Asset Vault a travs del getBitcoinAddress y registra este pedido en CryptoAddressBook.


.Relacionado al Redeem Point
1) Al iniciarse, notifica al communication server de su conexin y ubicacin.
2) Le solicita al Server los Redeem Points que estn cerca. (definir "cerca").

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description
.Relacionado al Asset Issuer
El DAP Manager, al detectar que se ha instalado la RedeemPoint wallet, habilitar los componentes de este networkservice, que al iniciarse
se registrar con el communication server.

En un determinado momento, llegar una peticin de comunicacin a travs del ActorNetworkService Issuer enviando una extended public Key para ser guardada
en la Redeem Point Address Book. De esta extended Public Key, el Redeem Point generar todas las claves pblicas y activar a la CRypto Network para que escuche transacciones
de estas direcciones.

Llegada una transaccin enviada a una de estas direcciones, se disparar un evento que generar el dbito en la Asset User Wallet.

.Relacionado al Asset User
Al iniciarse debe conectarse con el communication Server y notificar su posicin.
Si algn usuario est "cerca", recibir la solicitud de brindar informacin del Redeem Point a travs del communication server. Entre la informacin que estar pasando
al Asset User se encuentra la direccin de bitcoin generada a travs de la clave pblica.

== Plug-in Structure

== Events

== Implementation Details


:leveloffset: 1
= FERMAT-DAP /actor

:leveloffset: 1
[[referencie-wallet-asset-issuer-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[referencie-wallet-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details


:leveloffset: 1
= FERMAT-DAP /actor

:leveloffset: 1
[[wallet-module-asset-issuer-BitDubai-V1]]

== Version 1

El Modulo Asset Issuer implementara todo lo necesario para que permita creacin del Asset, con toda la informacin necesaria para proceder enviar dicho Asset al User que tenga dicha Asset instalada, y de esa manera poder saber con exactitud
todas las transacciones relacionadas al Asset que el Issuer origino.

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details


:leveloffset: 1
= FERMAT-DAP /actor

:leveloffset: 1
[[wallet-module-asset-issuer-BitDubai-V1]]
== Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details


:leveloffset: 1
= FERMAT-DAP /actor

:leveloffset: 1
[[wallet-asset-issuer-BitDubai-V1]]
== Version 1
El componente asset issuer wallet registrara todas las transacciones contables que ocurran en la Reference Asset Issuer Wallet, y almacenara dicha transaccin en la base de datos,
de esa manera el componente podra emitir todo los movimientos registrados en el Asset Issuer Wallet.
 Todas las transacciones deberan de pasar por el componente "Transacction" que sera en el que determine si la operacion debera ser persitida en la base de datos del componente asset
 issuer wallet.


== Plug-in Description
Se solicita a la Asset Vault una direccin bitcoin que ser la GenesisAddress. Esta direccin solicitada queda registrada en el Address Book como solicitada por el Issue Actor,
la plataforma DAP y la vault de donde sale la direccin.
Definir en que momento quedara como disponible.

== Plug-in Structure

    fermat-dap-api===&gt;layer===&gt;dap_wallet===&gt;asset_issuer_wallet

== Events

== Implementation Details

    Se crearan las siguientes Interfaces:
      assetissuerwallet:
         Implementara todo el objeto que manipulara la informacin de la Asset.
            *Metodos sugeridos:*

            String getWalletPublicKey();
            String getDigitalAssetPublicKey();
            long getBalance()  throws CantCalculateBalanceException;
            void debit(); //Debemos de definir la estructura de la transaccion
            void credit(); //Debemos de definir la estructura de la transaccion

      assetissuerwalletmanager:
         Implementara la interfaz publica hacia los otros pluggins.

      dealswithassetissuerwallet:
         Implementara la Interfaz BitCoinWalletAssetManager para la interconexion hacia los otros pluggins.

      assetissuerwallettransaction:
         Implementara la interfaz para el registro de la transaccin involucrada.

      assetissuerwalletsubsystem:
         Implementara la interfaz para el comportamiento del modulo.

:leveloffset: 1
[[wallet-asset-over-bitcoin-BitDubai-V1]]
== Version 1
    El componente Over Bitcoin Wallet registrara todas las transacciones contables que ocurran en la Reference Asset Wallet, y almacenara dicha transaccin en la base de datos,
  de esa manera el componente podra emitir todo los movimientos registrados en el Asset Wallets.


== Plug-in Description

== Plug-in Structure

    fermat-dap-api===&gt;wallet===&gt;fermat-dap-plugin-wallet-asset-over-bitcoin-bitdubai

== Events

== Implementation Details

    Se crearan las siguientes Interfaces:
      bitcoinwalletasset:
         Implementara todo el objeto que manipulara la informacin de la Asset.

      bitCoinwalletassetmanager:
         Implementara la interfaz publica hacia los otros pluggins.

      dealswithbitcoinwalletassets:
         Implementara la Interfaz BitCoinWalletAssetManager para la interconexion hacia los otros pluggins.

      bitcoinwalletassettransaction:
         Implementara la interfaz para el registro de la transaccin involucrada.

      bitcoinwalletassetsubsystem:
         Implementara la interfaz para el comportamiento del Pluggin.

:leveloffset: 1
[[wallet-asset-over-bitcoin-BitDubai-V1]]
== Version 1
    El componente Over Bitcoin Wallet registrara todas las transacciones contables que ocurran en la Reference Asset Wallet, y almacenara dicha transaccin en la base de datos,
  de esa manera el componente podra emitir todo los movimientos registrados en el Asset Wallets.


== Plug-in Description

== Plug-in Structure

    fermat-dap-api===&gt;wallet===&gt;fermat-dap-plugin-wallet-asset-over-bitcoin-bitdubai

== Events

== Implementation Details

    Se crearan las siguientes Interfaces:
      bitcoinwalletasset:
         Implementara todo el objeto que manipulara la informacin de la Asset.

      bitCoinwalletassetmanager:
         Implementara la interfaz publica hacia los otros pluggins.

      dealswithbitcoinwalletassets:
         Implementara la Interfaz BitCoinWalletAssetManager para la interconexion hacia los otros pluggins.

      bitcoinwalletassettransaction:
         Implementara la interfaz para el registro de la transaccin involucrada.

      bitcoinwalletassetsubsystem:
         Implementara la interfaz para el comportamiento del Pluggin.


:leveloffset: 1
= FERMAT-DAP /actor

:leveloffset: 1
[[wallet-module-asset-issuer-BitDubai-V1]]
== Version 1
    El Modulo Asset Issuer implementara todo lo necesario para que permita creacin del Asset, con toda la informacin necesaria para proceder enviar dicho Asset al User que tenga dicha Asset instalada, y de esa manera poder saber con exactitud
todas las transacciones relacionadas al Asset que el Issuer origino.

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details





:leveloffset: 0
== Iniciacin en fermat sobre la plataforma Android

=== Comenzar con una breve introduccion a la aplicacin para que sepan cual ser su ubicacin dentro de Fermat.

Basicamente deberia comenzar con el concepto de wallet o cartera. Una Wallet es un applicacin que en su version ms simple nos permite enviar y recibir dinero. En este caso nos abocamos al intercambio de cryptocurrencies (por el momento Bitcoins).
A partir de este concepto podemos decir que lo que nosotros estamos construyendo es una fabrica de Wallet, las cuales derivan de una wallet padre llamada reference Wallet. Aqu es donde nos vamos a centrar en este momento en la capa de Android:
La reference Wallet posee 5 tabs en este momento, cada uno con una funcin especifica:

* Transaction: permite ver todas las transacciones realizadas, se hace una diferenciacin por transacciones en Book balance y en Available balance
* Contacts:    permite ver un listado de contactos disponibles y posee un boton el cual permite el ingreso
* Send:        permite enviar bitcoins a un contacto o a una direccin de wallet desconocida por medio de su address
* Receive:     permite recibir bitcoins obteniendo una direccion para que otras wallet puedan enviar el dinero
* Balance:     permite ver el saldo disponible en el book balance y el availabe balance

Luego de los tabs en este momento se encuentra:

*  CreateContacts: pantalla que nace al hacer un click sobre el boton que se encuentra en el tab Contacts, como su nombre lo indica este fragmento se encarga de la creacion de los contactos

== Manejo de sesiones:
Uno de los problemas encontrados es la persistencia de datos en memoria ya que como conocen el ciclo de vida un fragmento al no estar visible se elimina y se vuelve a crear al llamarlo nuevamente. Estos datos deben estar guardados en algn lugar en caso de que el usuario quiera cambiar de wallet y dejar la sesion abierta, para resolver esto se implement la creacin de una sesin por cada wallet y un wallet manager que se encarga de la gestin de dichas sesiones teniendo as la posibilidad de regresar al momento en el que se encontraba el usuario al cambiar de pantalla.
El developer puede as persistir objetos en la sesin de cualquier tipo, dentro de un map que trabaja con una key y el objeto que el developer necesite guardar.

== Manejo de la estructura de navegacin:
Como lo habrn notado Fermat es una aplicacin distinta al resto de las aplicaciones android, posee una estructura de navegacin propia. la cual se basa en pantallas y subPantallas que se van "pintando" desde objetos cargados en tiempo de ejecucin , desde archivos, que entregan la informacin sobre que es lo que se necesita dibujar en cada pantalla/sub pantalla.
Para realizar esto a nivel de la Reference wallet hay un mecanismo implementado:

* Cada tipo de Wallet posee un Enum con los fragmentos, que se llama por medi de un Factory (en el core) y te dice que controladores se pueden "pintar" en pantalla, con esto quiero decir un identificador de la libreria a la cual debe ir a buscar los fragmentos (controladores) para la wallet. Los nombres de estos fragmentos deben estar en la estructura de navegacin de la wallet para ser invocados.
* En la estructura de navegacin tambien se pueden determinar tabs,colores,acciones, posiciones de las fragmentos a la hora de hacer el back, entre otras cosas.


= FERMAT: expanding the cryptoworld (the official book)

:leveloffset: 0
[[fbk-01 Welcome to FERMAT]]
== Welcome to FERMAT !

=== Beyond Bitcoin: FERMAT

((("fermat", id="ix_fbk-01-asciidoc0", range="startofrange")))((("fermat","defined")))
FERMAT is an inspired vision, a project to attain this vision, a group of pioneers of the software development industry working on it, a community supporting the core idea and providing the environment, and the whole world of potential users who will profit and be served by this.
FERMAT's vision is based on the huge potential of the blockchain transaction technology underlying the first sucessfully implemented cryptocurrency: Bitcoin. The undeniable goal of Bitcoin's crytographic based electronic signature protocol that builds a distributed public ledger of peer-to-peer electronic transactions opens the door to a new paradigma in economics, computer science, financial operations, and world-wide commerce. Sakamoto's invention makes possible to unveil the world of financial transactions, to get rid of the necessity of trust into a third party institution or central goverments, to make money a secure thing, and transactions transparent and effortless, giving back the absolute control to the money's owner. The cryptocurrency scheme encourages us to adopt a radical new point of view on money and the concept fo value itself and its transport, so radical, that it will take us some time and effort to really grasp it, because it leads to unconditionally honoring and empowering of each individual.
FERMAT as a project is also a big challenge to the open source software industry because it firmly believes that the comunnity has much more talent and intelligent collectively than isolated individuals, and the project is inscribed in the wolrd-wide cryptoindustry ecosystem with the conviction of laying the seeds of a global collaborative endeavourw ith a firm call to commited collaboration from peers and colleagues.
FERMAT from its conception is addressed to pioneers, and we have already engaged a solid core of software developers that is working in shaping the first version of the platform to be soon released.

FERMAT is, technically speaking , an Open Source P2P (Peer-to-Peer) System built on a Plug-in Architecture running on end-user's devices. The first goal is to get very close to the end user offering and easy way of coming onboard the crytocurrency world by means of and insutitively easy to access cryptocurrency Wallet. At the same time, the open source plug-in platform allow any skilled actor in the community to jump in and develop applications and offering services with different abstractin levels and addressing a wide range of segmented markets. In fact, FERMAT as whole sets a common ground, a kind of "Master Plan" for developing wallets, wallet services, p2p network services and all kind of future develpments based in blockchain tech, using the existent global talent and intelligence that the community already has and collaborating with very intense feedback in expanding this technology to reach rapidily end user's mass adoption, giving all the participants in the different sectors a sense of trust, safety and equity, and the corresponding right to become a revenue for each one's contribution and effort.
Instead of begginning a new project in this industry completley from zero point, the clear and firm logic of FERMAT can turn it to become a new standard in the industry by giving the collective a group coherence as it had never before, and encourages to grow safely in a collaborative way.

.Challenges and opportunities: inspiration from Fermat's Last Theorem
****

((("bitcoin","precursors to")))
---------------------
As you may have noticed, the entire project has been named following the famous mathematical puzzle that haunted generations of mathemathicians until it was finally proven after 350 years. (if you are courious about the whole story, see http: ....    ).
It is so because this project was born when trying to solve the new questions, issues and puzzles that the genious Sakamoto's solution to an old cryptographic called , which let him consolidet the foundation of Bitcoin, the first sucessfull cryptocurrency. (for a wonderful detailed introduction to Bitcoin's world, please refer to the "must read"excellent book of Antonio Papadopoulos "Mastering Bitcoin").

The "puzzle"to solve in the emerging field of blockchain tecnology is related to finding the answers to the following questions:

* How can we isolate ordinary people from the perceived complexity?
* How can we use the collective intelligence of the developer community?
* How can we reuse the entire current infrastructure already in place?
* How do we integrate legacy financial institutions in a way they feel comfortable?
* How do we integrate merchants, retailers and brands of all sizes in a clever way?

The answers to each of these questions are addressed within the FERMAT platform.
****

=== FERMAT's Mission:

&gt; Empower every person in the world with the appropriate tools to save and move their money in a digital format in an efficient, secure an private way. And at the same time allow them to choose which currency to use, regardless of the place they live or where they were born.


=== What makes FERMAT different from other wallet platforms or services?

* **FERMAT is P2P.** This makes it censorship resistent and difficult to be attacked.

* **FERMAT is built with plugins.** This enables functionality to be reused and opens the door to any developer to participate.

* **FERMAT runs on end users' devices.** This enables users to hold their own money eliminating the need to trust a third party.

* **FERMAT is inclusive.** By creating their own plugins, current industry members can integrate with FERMAT to offer their services and products to FERMAT user base.

* **FERMAT segments the world population and offers a custom tailored solution for each segment.** Any developer can easily create niche wallets for a particular group of people. Brands can create their own wallets for their followers. All the heavy lifting is done by the FERMAT platform.

* **FERMAT guaratees plugins and wallet developers a revenue stream.** FERMAT implements an innovative business model which allows plugins and wallet developers to define a use license, and FERMAT itself enforces this license on behalf of developers. )



=== FERMAT's Principles

==== 1. FERMAT should not allow censorship.
* Open Source.
* P2P architecture.

#### 2. FERMAT should not allow spying on their user base.


* Point to point encrypted communications.
* Geofenced P2P network enabling the shortest communication path between peers.
* Multi-technology communication layer (cloud, p2p, wifi, bluetooth, nfc, mesh, etc.).


#### 3. FERMAT should be secure and resistant to all kind of attacks.


* No centralized point to be attacked.
* Multiple identities and roles per user.
* Device Private Network (DPN) concept.
* Pocket Money concept and a Multi-Signature Vault owned by the DPN.
* Reviews and Reputation concepts.


#### 4. FERMAT should never loose a user's funds.


* Transaction responsability transmission protocols.
* Remote technical support by wallet and plugins developers.


#### 5. FERMAT should be usefull to each segment of the world population.


* Niche wallets concept.
* Branded wallets concept.


#### 6. FERMAT should be extensible and open to innovation.


* Plugins architecture.
* Multi dimensional layer architecture.


#### 7. FERMAT should be open and inclusive.


* Any developer could contribute to the shared infraestructure.
* Any developer could write code for new plugins.
* Any developer could write code for new niche wallets.
* Any developer could fork an existing niche wallet to further specialize it.
* Any graphic / UX designer could provide skins to existing wallets.
* Anyone could provide language packs to existing wallets.


#### 8. Each developer should be compesated by their contribution to FERMAT.


* Micro license concept.
* Micro license structure concept.
* FERMAT automatically enforcing license agreements.
* Plugin ownership concept.
* Niche wallet ownership concept.
* Branded wallet onwnership concept.
* Master plan design comcept, wiht no overlaping functionality but shared ownership.


#### 9. FERMAT user base should be a shared asset.


* Any developer should be able to profit from the growing FERMAT user base by writing Plugins this user base could consume via the developers of the wallets they are using.


#### 10. FERMAT should be inclusive with crypto currency industry members.

* Any bitcoin | crypto | blockchain established startup could write their own plugins and expose their services to both FERMAT developers and the FERMAT user base.
* Any alt-coin community could write plugins to enable their crypto currency within the FERMAT wallet ecosystem.


#### 11. FERMAT should be inclusive with the current financial system.


* Banks and financial institutions could write plugins to enable FERMAT wallets hold funds in banks and other financial institutions.

* FERMAT allows it users to move money both through public value transport networks as crypto currency networks and also thwough private or legacy financial networks.


#### 12. FERMAT should be unbanked-people friendly.


* Multiple logins per device (Device user concept)
* Crypto banking concept.


#### 13. FERMAT should be OS agnostic.


* OSA layer concept (Operative System API).
* OS dependent UI on top of FERMAT concept.


#### 14. FERMAT should learn from its user base.


* Integrated feedback functionality.
* Voting over feature wish-lists concept.


#### 15. FERMAT should be the finacially most efficient way to move or spend the end user's money.


* Crypto Vault for multiple wallets concept.
* Financial AI Agents concept.


#### 16. FERMAT should facilitate the regional distribution and access to crypto currencies.


* Crypto Distribution Network concept.
* Crypto Brokers concept.


</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-09-28 10:58:02 ART
</div>
</div>
</body>
</html>